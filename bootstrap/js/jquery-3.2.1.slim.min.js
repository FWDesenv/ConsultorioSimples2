/ *! jQuery v3.2.1 -ajax, -ajax / jsonp, -jajax / load, -ajax / parseXML, -ajax / script, -ajax / var / location, -ajax / var / nonce, -ajax / var / rquery, -ajax / xhr, -manipulation / _evalUrl, -event / ajax, -effects, -effects / Tween, -effects / animatedSelector | (c) Fundação JS e outros colaboradores | jquery.org/license * /
! function (a, b) {"use strict"; "objeto" == typeof module && "object" == typeof module.exports? module.exports = a.document? b (a,! 0): function (a) {if (! a.document) throw new Error ("jQuery requer uma janela com um documento"); return b (a)}: b (a)} (janela "indefinida"! = typeof window?: this, function ( a, b) {"use strict"; var c = [], d = a.document, e = Object.getPrototypeOf, f = c.slice, g = c.concat, h = c.push, i = c. indexOf, j = {}, k = j.toString, l = j.hasOwnProperty, m = l.toString, n = m.call (Object), o = {}; função p (a, b) {b = b || d; var c = b.createElement ("script"); c.text = a, b.head.appendChild (c) .parentNode.removeChild (c)} var q = "3.2.1 -ajax, -ajax / jsonp, -ajax / load, -ajax / parseXML, -ajax / script, -ajax / var / location, -jajax / var / nonce, -jajax / var / rquery, -ajax / xhr, -manipulation / _evalUrl, - event / ajax, -effects, -effects / Tween,-effects / animatedSelector ", r = função (a, b) {retornar novo r.fn.init (a, b)}, s = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0 ] + $ / g, t = / ^ - ms - /, u = / - ([az]) / g, v = função (a, b) {retorno b.toUpperCase ()}; r.fn = r. prototype = {jquery: q, construtor: r, comprimento: 0, toArray: function () {retorno f.call (this)}, get: function (a) {retorno null == a? f.call (este): a <0? this [a + this.length]: this [a]}, pushStack: function (a) {var b = r.merge (this.constructor (), a); retorno b.prevObject = isto, b }, each: function (a) {return r.each (this, a)}, map: function (a) {retornar this.pushStack (r.map (isso, função (b, c) {return a.call ( b, c, b)}))}, slice: function () {retornar this.pushStack (f.apply (this, arguments))}, first: function () {retornar this.eq (0)}, last: function () {retornar this.eq (-1)}, eq: function (a) {var b = este.length, c = + a + (a <0? b: 0); retorne this.pushStack (c> = 0 && c <b? [This [c]]: [])}, end: function () {retornar this.prevObject || isto.construtor ()}, push: h, classificar: c.sort, splice: c.splice}, r.extend = r.fn.extend = function () {var a, b, c, d, e, f, g = argumentos [0] || {}, h = 1, i = argumentos.length, j =! 1; para ("boolean" == typeof g && (j = g, g = argumentos [h] || {}, h ++), "objeto" == typeof g || r.isFunction (g) || (g = {}), h === i && (g = isto, h -); h <i; h ++) if ( null! = (a = argumentos [h])) para (b em a) c = g [b], d = a [b], g! == d && (j && d && (r.isPlainObject (d) || (e) = Array.isArray (d)))? (E? (E =! 1, f = c && Array.isArray (c)? C: []): f = c && r.isPlainObject (c)? C: {}, g [ b] = r.extend (j, f, d)): void 0! == d && (g [b] = d)); return g}, r.extend ({expando: "jQuery" + (q + Math .random ()). replace (/ \ D / g, ""), isReady:! 0, erro: function (a) {lançar novo Erro (a)}, noop: function () {}, isFunction: function ( a) {return "function" === r.type (a)}, isWindow: function (a) {retorno nulo! = a && a === a.window},isNumérico: function (a) {var b = r.type (a); return ("número" === b || "string" === b) &&! isNaN (a-parseFloat (a))}, isPlainObject : function (a) {var b, c; retorno! (! a || "[objeto Objeto]"! == k.call (a)) && (! (b = e (a)) || (c = l.call (b, "construtor") && b.constructor, "função" == typeof c && m.call (c) === n))}, isEmptyObject: função (a) {var b; para (b em a) return! 1; return! 0}, tipo: function (a) {retorno null == a? a + "": "objeto" == typeof a || "function" == tipoof a? j [k.call (a )] || "objeto": typeof a}, globalEval: function (a) {p (a)}, camelCase: function (a) {return a.replace (t, "ms -"). substitua (u, v )}, cada: function (a, b) {var c, d = 0; if (w (a)) {para (c = a.length; d <c; d ++) if (b.call (a [d ], d, a [d]) ===! 1) break} mais para (d em a) if (b.call (a [d], d, a [d]) ===! 1) quebra; return a}, trim:function (a) {return null == a? "" :( a + ""). replace (s, "")}, makeArray: function (a, b) {var c = b || []; retorno nulo! = a && (w (Objeto (a))? r.merge (c, "string" == tipoof a? [a]: a): h.call (c, a)), c}, inArray: function (a , b, c) {retorno null == b? -1: i.call (b, a, c)}, mesclagem: function (a, b) {para (var c = + b.length, d = 0, e = a.length; d <c; d ++) a [e ++] = b [d]; retorno a.length = e, a}, grep: function (a, b, c) {para (var d, e = [], f = 0, g = a.length, h =! c; f <g; f ++) d =! b (a [f], f), d! == h && e.push (a [f]) ; return e}, map: function (a, b, c) {var d, e, f = 0, h = []; se (w (a)) para (d = a.length; f <d; f ++ ) e = b (a [f], f, c), nulo! = e && h.push (e); else para (f em a) e = b (a [f], f, c), nulo! = e & h .push (e); retorno g.apply ([], h)}, guid: 1, proxy: função (a, b) {var c, d, e; if ("string" == typeof b && (c = a [b], b = a, a = c), r.isFunção (a)) return d = f.call (argumentos, 2), e = function () {return a.apply (b || isto,d.concat (f.call (argumentos)))}, e.guid = a.guid = a.guid || r.guid ++, e}, agora: Date.now, suporte: o}), "function" = = typeof Símbolo && (r.fn [Symbol.iterator] = c [Symbol.iterator]), r.each ("Número da Função da String Booleana Data da Matriz RegExp Object Error Symbol" .split (""), função (a, b) {j ["[objeto" + b + "]"] = b.toLowerCase ()}); função w (a) {var b = !! a && "comprimento" em a && a.length, c = r.type (a) ; return "function"! == c &&! r.isWindow (a) && ("array" === c || 0 === b || "número" == typeof b && b> 0 && b-1 em a)} var x = função (a) {var b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u = "sizzle "+ 1 * nova data, v = a.document, w = 0, x = 0, y = ha (), z = ha (), A = ha (), B = função (a, b) {return a === b && (l =! 0), 0}, C = {} .DownProperty, D = [], E = D.pop, F = D.push, G = D.push, H = D.slice, I = função (a,b) {para (var c = 0, d = a.length; c <d; c ++) se (a [c] === b) retornar c; retorno-1}, J = "verificado | selecionado | async | autofocus | autoplay | controls | defer | disabled | oculto | ismap | loop | multiple | open | readonly | obrigatório | scoped ", K =" [\\ x20 \\ t \\ r \\ n \\ f] ", L = "(?: \\\\. | [\\ w-] | [^ \ 0 - \\ xa0]) +", M = "\\ [" + K + "* (" + L + ") (? : "+ K +" * ([* ^ $ |! ~]? =) "+ K +" * (?: '((?: \\\\. | [^ \\\\']) *) '| \ "((?: \\\\. | [^ \\\\\"]) *) \ "| (" + L + ")) |)" + K + "* \\]", N = ": ("+ L +") (?: \\ ((('((?: \\\\. | [^ \\\\']) *) '| \ "((?: \\\\. | [^ \\\\\ "]] *) \") | ((?: \\\\. | [^ \\\\\ () [\\]] | "+ M +") *) |. * ) \\) |) ", O = new RegExp (K +" + "," g "), P = novo RegExp (" ^ "+ K +" + | ((?: ^ | [^ \\\\]) (?: \\\\.) *) "+ K +" + $ "," g "), Q = novo RegExp (" ^ "+ K +" *, "+ K + "*"), R = novo RegExp ("^" + K + "* ([> + ~] |" + K + ")" + K + "*"), S = novo RegExp ("=" + K + " * ([^ \\] '\ "] *?)" + K + "* \\]", "g"), T = novo RegExp (N), U = novo RegExp ("^" + L + "$" ), V = {ID: new RegExp ("^ # (" + L + ")"), CLASS: new RegExp ("^ \\. (" + L + ")"), TAG: new RegExp ("^ (" + L + "| [*])"), ATTR: novo RegExp ("^" + M), PSEUDO: novo RegExp ("^" + N), CHILD: novo RegExp ("^ :( somente | primeiro | último | nth | nth-last) - (filho | do-type) (?: \\ ("+ K +" * (par | ímpar | (([+ -] |) (\\ d *) n |) "+ K + "* (?: ([+ -] |)" + K + "* (\\ d +) |))" + K + "* \\) |)", "i"), bool: new RegExp ("^ ( ?: "+ J +") $ "," i "), needsContext: new RegExp (" ^ "+ K +" * [> + ~] |: (par | ímpar | eq | gt | lt | nth | primeiro | último ) (?:\\ ("+ K +" * ((?: - \\ d)? \\ d *) "+ K +" * \\) |) (? = [^ -] | $) "," i ")} , W = / ^ (?: input | select | textarea | botão) $ / i, X = / ^ h \ d $ / i, Y = / ^ [^ {] + \ {\ s * \ [nativo \ w /,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=novo RegExp ("\\\\ ([\\ da-f] {1,6}" + K + "? | (" + K + ") |.)", "Ig"), aa = função (a, b, c) {var d = "0x" + b-65536; retorno d! == d || c? b: d <0? String.fromCharCode (d + 65536): String.fromCharCode (d >> 10 | 55296, 1023 & d | 56320)}, ba = / ([\ 0- \ x1f \ x7f] | ^ -? \ D) | ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w -] / g, ca = função (a, b) {retorno b? "\ 0" === a? "\ ufffd": a.slice (0, -1) + "\\" + a.charCodeAt (a.length-1 ) .toString (16) + "": "\\" + a}, da = função () {m ()}, ea = ta (função (a) {return a.disabled ===! 0 && ("form "in a ||" label "em a)}, {dir:" parentNode ", próximo:" legend "});try {G.apply (D = H. chamada (v.childNodes), v.childNodes), D [v.childNodes.length] .nodeType} catch (fa) {G = {aplicar: D.length? function (a , b) {F.apply (a, H.chame (b))}: função (a, b) {var = a.length, d = 0; enquanto (a [c ++] = b [d ++]); a.length = c-1}}} função ga (a, b, d, e) {var f, h, j, k, l, o, r, s = b && b.ownerDocument, w = b? b.nodeType : 9; if (d = d || [], "string"! = Typeof a ||! A || 1! == w && 9! == w && 11! == w) return d; if (! E && ((b b.ownerDocument || b: v)! == n && m (b), b = b || n, p)) {se (11! == w && (l = Z.exec (a))) se (f = l [1]) {if (9 === w) {if (! (j = b.getElementById (f))) retorno d; se (j.id === f) retornar d.push (j) , d} else if (s && (j = s.getElementById (f)) && t (b, j) && j.id === f) retorne d.push (j), d} mais {if (l [2]) return G.apply (d, b.getElementsByTagName (a)), d; se ((f = l [3]) && c.getElementsByClassName && b.getElementsByClassName) retorna G.apply (d, b.getElementsByClassName (f)), d} if (c.qsa &&! A [a + ""] && (! q ||! q.test (a))) {se (1! == w) s = b, r = a; else if ("objeto"! == b.nodeName.toLowerCase ()) {(k = b.getAttribute ("id"))? k = k.replace (ba, ca): b.setAttribute ("id ", k = u), o = g (a), h = o.length; enquanto (h -) o [h] =" # "+ k +" "+ sa (o [h]); r = o .join (","), s = $. test (a) && qa (b.parentNode) || b} se (r) tentar {retornar G.apply (d, s.querySelectorAll (r)), d} (x) {} finalmente {k === u && b.removeAttribute ("id")}}} retornar i (a.replace (P, "$ 1"), b, d, e)} função ha () {var = []; função b (c, e) {retornar a.push (c + "")> d.cacheLength && excluir b [a.shift ()], b [c + ""] = e} retornar b} função ia (a ) {return a [u] =! 0, a} function ja (a) {var b = n.createElement ("fieldset"); tente {return !! a (b)} catch (c) {return! 1} finalmente {b.parentNode && b.parentNode.removeChild (b), b = null}} ka (a, b) {var = a.split ("|"), e = c.length; while (e -) d.attrHandle [c [ e]] = b} função la (a, b) {var = b && a, d = c && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex-b.sourceIndex; if (d) return d; c) while (c = c.nextSibling) if (c === b) return-1; retorne a função? 1: -1} ma (a) {função return (b) {var = b.nodeName.toLowerCase (); return "input" === c && b.type === a}} function na (a) {função return (b) {var = b.nodeName.toLowerCase (); return ("input" === c || "botão" === c) && b.type === a}} função oa (a) {return function (b) {retorno "form" em b? b.parentNode && b.disabled ===! 1? "label" em b? "label" em b.parentNode? b.parentNode.disabled === a: b.disabled === a: b.isDisabled === a || b.isDisabled! ==! a && ea ( b) === a: b.disabled === a: "label"em b && b.disabled === a}} function pa (a) {return ia (função (b) {retorno b = + b, ia (função (c, d) {var e, f = a ([], c Comprimento, b), g = f.length, enquanto (g -) c [e = f [g]] && (c [e] =! (d [e] = c [e]))})} )} function qa (a) {return a && "undefined"! = typeof a.getElementsByTagName && a} c = ga.support = {}, f = ga.isXML = função (a) {var b = a && (a.ownerDocument || a) .documentElement; return !! b && "HTML"! == b.nodeName}, m = ga.setDocument = função (a) {var b, e, g = a? proprietário.documento || a: v; retorno g! == n && 9 === g.nodeType && g.documentElement? (n = g, o = n.documentElement, p =! f (n), v! == n && (e = n.defaultView) && e.top! = e && (e.addEventListener? e.addEventListener ("descarregar", da,! 1): e.attachEvent && e.attachEvent ("onunload", da)), c.attributes = ja (funo (a) {return a.className = "i",! a.getAttribute ("className ")}), c.getElementsByTagName = ja (function (a) {retornar a.appendChild (n.createComment (" ")) ,! a.getElementsByTagName (" * "). length}), c.getElementsByClassName = Y .test (n.getElementsByClassName), c.getById = ja (function (a) {retornar o.appendChild (a) .id = u,! n.getElementsByName ||! n.getElementsByName (u) .length}), c .getById? (d.filter.ID = função (a) {var b = a.replace (_, aa); função de retorno (a) {return a.getAttribute ("id") === b}}, d .find.ID = function (a, b) {se ("indefinido"! = tipo de b.getElementById && p) {var = b.getElementById (a); retorno c? [c]: []}}) :( d .filter.ID = function (a) {var b = a.replace (_, aa); função de retorno (a) {var c = "indefinido"! = tipo de a.getAttributeNode && a.getAttributeNode ("id"); return c && c .value === b}}, d.find.ID = função (a, b) {if ("indefinido"! = tipo de b.getElementById &&p) {var c, d, e, f = b.getElementById (a); if (f) {se (c = f.getAttributeNode ("id"), c && c.value === a) retorno [f]; e = b.getElementsByName (a), d = 0; while (f = e [d ++]) if (c = f.getAttributeNode ("id"), c && c.value === a) retorno [f]} retorno [ }}}), d.find.TAG = c.getElementsByTagName? function (a, b) {retorno "undefined"! = tipo de b.getElementsByTagName? b.getElementsByTagName (a): c.qsa? b.querySelectorAll (a) : void 0}: function (a, b) {var c, d = [], e = 0, f = b.getElementsByTagName (a); if ("*" === a) {while (c = f [ e ++]) 1 === c.nodeType && d.push (c); retorno d} retorno f}, d.find.CLASS = c.getElementsByClassName && function (a, b) {if ("indefinido"! = tipo de b.getElementsByClassName && p) return b.getElementsByClassName (a)}, r = [], q = [], (c.qsa = Y.test (n.querySelectorAll)) && (ja (função (a) {o.appendChild (a) .innerHTML = "<a id = '" + u + "'> </a> <select id =' "+ u +" - \ r \\ 'msallowcapture =' '> <opção selecionada =' '> </ option> </ select> ", a.querySelectorAll (" [msallowcapture ^ = ''] "). length && q.push (" [* ^ $] = "+ K +" * (?: '' | \ "\") "), a.querySelectorAll (" [selecionado] "). || q.push ("\\ [" + K + "* (?: valor |" + J + ")"), a.querySelectorAll ("[id ~ =" + u + "-]"). comprimento || q .push ("~ ="), a.querySelectorAll (": checked"). length || q.push (": marcado"), a.querySelectorAll ("a #" + u + "+ *"). length || q.push (". #. + [+ ~]")}), ja (função (a) {a.innerHTML = "<a href='' disabled='disabled'> </a> <selecione desativado = 'desativado'> <opção /> </ select> ";var b = n.createElement ("entrada"); b.setAttribute ("tipo", "oculto"), a.appendChild (b) .setAttribute ("nome", "D"), a.querySelectorAll ("[nome = d] "). length && q.push (" nome "+ K +" * [* ^ $ |! ~]? = "), 2! == a.querySelectorAll (": ativado "). length && q.push (": enabled ",": disabled "), o.appendChild (a) .disabled =! 0,2! == a.querySelectorAll (": desativado "). length && q.push (": enabled ",": disabled "), a.querySelectorAll ("* ,: x"), q.push (",. *:")})), (c.matchesSelector = Y.test (s = o.matches || o.webkitMatchesSelector || o. mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ja (function (a) {c.disconnectedMatch = s.call (a, "*"), s.call (a, "[s! = '']: x "), r.push ("! = ", N)}), q = q.length && new RegExp (q.join ("|")), r = r.length && new RegExp (r.join ("|")), b = Y.test (o.pareDocumentPosition), t = b || Y.test ( o.contains)? function (a, b) {var = 9 == = a.nodeType? a.documentElement: a, d = b && b.parentNode; retorno a === d ||! (! d || 1 ! == d.nodeType ||! (c.contains? c.contains (d): a.compareDocumentPosition && 16 & a.compareDocumentPosition (d))): function (a, b) {se (b) while (b = b. parentNode) if (b === a) retornar! 0; retornar! 1}, B = b? função (a, b) {if (a === b) retornar l =! 0,0; var d =! a.compareDocumentPosition-! b.compareDocumentPosition; return d? d: (d = (a.ownerDocument || a) === (b.ownerDocument || b)? a.compareDocumentPosition (b): 1,1 & d ||! c.sortDetached && b.compareDocumentPosition (a) === d? a === n || a.ownerDocument === v && t (v, a)? - 1: b === n || b.ownerDocument === v && t (v, b)? 1: k? I (k, a) -I (k, b): 0: 4 & d? -1: 1)}: funï¿½o (a, b) {se (a = = b) return l =! 0,0;var c, d = 0, e = a.parentNode, f = b.parentNode, g = [a], h = [b]; se (! e ||! f) retorna a === n? -1: b = n = 1: e -1: f 1: k I (k, a) I (k, b): 0; se (e = = f) retorne la (a, b) ; c = a; while (c = c.parentNode) g.unshift (c); c = b; enquanto (c = c.parentNode) h.unshift (c); enquanto (g [d] === h [ d]) d ++; retorno d? la (g [d], h [d]): g [d] === v? -1: h [d] === v? 1: 0}, n): n}, ga.matches = function (a, b) {return ga (a, nulo, nulo, b)}, ga.matchesSelector = função (a, b) {if ((a.ownerDocument || a)! = = n && m (a), b = b.replace (S, "= '$ 1']"), c.matchesSelector && p &&! A [b + ""] && (! r ||! r.test (b)) && (! q ||! q.test (b))) tente {var d = s.call (a, b); se (d || c.disconnectedMatch || a.document && 11! == a.document.nodeType) retorne d } catch (e) {} retorna ga (b, n, nulo, [a]). length> 0}, ga.contains = função (a, b) {retorno (a.ownerDocument || a)! == n && m (a), t (a, b)}, ga.attr = função (a, b) {(a.ownerDocument || a)! == n && m (a);var e = d.attrHandle [b.toLowerCase ()], f = e & C.call (d.attrHandle, b.toLowerCase ())? e (a, b,! p): void 0; return void 0! == f? f: c.attributes ||! p? a.getAttribute (b): (f = a.getAttributeNode (b)) && f.specified? f.value: null}, ga.escape = funo (a) {retorno (a + ""). replace (ba, ca)}, ga.error = função (a) {throw new Erro ("Erro de sintaxe, expressão não reconhecida:" + a)}, ga.uniqueSort = function (a) {var b, d = [], e = 0, f = 0; se (l =! c.detectDuplicates, k =! c.sortStable && a.slice (0), a.sort (B), l) {while (b = a [f ++]) b === a [f] && (e = d.push (f)); enquanto (e -) a.splice (d [e], 1)} retorna k = nulo, a} , e = ga.getText = função (a) {var b, c = "", d = 0, f = a.nodeType; if (f) {se (1 === f || 9 === f | | 11 === f) {if ("string" == typeof a.textContent) retorna a.textContent; para (a = a.firstChild; a; a = a.nextSibling) c + = e (a)} else se (3 === f || 4 === f) return a.nodeValue} else while (b = a [d ++]) c + = e (b);return c}, d = ga.selectors = {cacheLength: 50, createPseudo: ia, correspondência: V, attrHandle: {}, find: {}, relative: {">": {dir: "parentNode", primeiro:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", primeiro:! 0}, "~": {dir: "previousSibling"}}, preFilter: {ATTR: function (a) {return a [1] = a [1] .replace (_, aa), a [3] = (a [3] || a [4] || a [5] || ""). substituir (_, aa), "~ =" === a [2] && (a [3] = "" + a [3] + ""), a.slice (0,4)}, CHILD: function (a) {return a [1] = a [1] .toLowerCase (), "nth" === a [1] .slice (0,3)? (a [3] || ga.error (a [ 0]), a [4] = + (a [4]? A [5] + (a [6] || 1): 2 * ("par" === a [3] || "ímpar" = == a [3])), a [5] = + (a [7] + a [8] || "ímpar" === a [3])): a [3] && ga.error (a [ 0]), a}, PSEUDO: function (a) {var b, c =! A [6] && a [2]; retorno V.CHILD.test (a [0]) null:(a [3]? a [2] = a [4] || a [5] || "": c && T.test (c) && (b = g (c,! 0)) && (b = c. indexOf (")", c.length-b) -c.length) && (a [0] = a [0] .slice (0, b), a [2] = c.slice (0, b)) , a.slice (0,3))}}, filtro: {TAG: função (a) {var b = a.replace (_, aa) .toLowerCase (); retorno "*" === a? função ( ) {return! 0}: function (a) {return a.nodeName && a.nodeName.toLowerCase () === b}}, CLASS: function (a) {var b = y [a + ""]; retorno b || (b = new RegExp ("(^ |" + K + ")" + a + "(" + K + "| $)")) && y (a, function (a) {retorno b.test ("string" == tipo de a.className && a.className || "undefined"! = typeof a.getAttribute && a.getAttribute ("classe") || "")})}, ATTR: function (a, b, c) {função de retorno (d) {var e = ga.attr (d, a); retorno nulo == e? "! =" === b:! b || (e + = "", "=" === b? e === c:"! =" === b? e! == c: "^ =" === b? c && 0 === e.indexOf (c): "* =" === b? c && e.indexOf (c) > -1: "$ =" === b? C && e.slice (-c.length) === c: "~ =" === b? ("" + E.replace (O, "") + "") .indexOf (c)> - 1: "| =" === b && (e === c || e.slice (0, c.length + 1) === c + "-")}} }, CHILD: função (a, b, c, d, e) {var f = "nth"! == a.slice (0,3), g = "last"! == a.slice (-4) , h = "do tipo" === b; retorno 1 === d && 0 === e? function (a) {retorno !! a.parentNode}: function (b, c, i) {var j, k , l, m, n, o, p = f! == g? "nextSibling": "previousSibling", q = b.parentNode, r = h && b.nodeName.toLowerCase (), s =! i &&! h, t = ! 1; if (q) {se (f) {enquanto (p) {m = b; enquanto (m = m [p]) se (h? M.nodeName.toLowerCase () === r: 1 == = m.nodeType) return! 1; o = p = "somente" === a &&! o && "nextSibling "} return! 0} if (o = [g? q.firstChild: q.lastChild], g && s) {m = q, l = m [u] || (m [u] = {}), k = l [m.uniqueID] || (l [m.uniqueID] = {}), j = k [a] || [], n = j [0] === w && j [1], t = n && j [2 ], m = n && q.childNodes [n]; while (m = ++ n && m && m [p] || (t = n = 0) || o.pop ()) if (1 === m.nodeType && ++ t && m === b) {k [a] = [w, n, t]; quebra}} mais se (s && (m = b, l = m [u] || (m [u] = {}), k = l [m.uniqueID] || (l [m.uniqueID] = {}), j = k [a] || [], n = j [0] === w && j [1], t = n) , t ===! 1) while (m = ++ n && m && m [p] || (t = n = 0) || o.pop ()) if ((h? m.nodeName.toLowerCase () === r: 1 === m.nodeType) && ++ t && (s && (l = m [u] || (m [u] = {}), k = l [m.uniqueID] || (l [m. uniqueID] = {}), k [a] = [w, t]), m === b)) quebra; retorno t- = e, t === d || t% d === 0 && t / d > = 0}}}, PSEUDO: function (a, b) {var c, e = d.pseudos [a] || d.setFilters [a.toLowerCase ()] || ga.error ("pseudo não suportado:" + a);return e [u] e (b): e.length> 1 (c = [a, a, "", b], d.setFilters.hasOwnProperty (a.toLowerCase ())? ia (função (a, c) {var d, f = e (a, b), g = f.length, enquanto (g -) d = I (a, f [g]), a [d] =! (c [d] = f [g])}): function (a) {return e (a, 0, c)}): e}}, pseudos: {não: ia (função (a) {var b = [], c = [], d = h (a.replace (P, "$ 1")); retorno d [u] ia (função (a, b, c, e) {var f, g = d (a, nulo, e , []), h = a.length, while (h -) (f = g [h]) && (a [h] =! (b [h] = f))}): função (a, e , f) {return b [0] = a, d (b, nulo, f, c), b [0] = nulo,! c.pop ()}}), tem: ia (função (a) {retorno function (b) {return ga (a, b) .comprimento> 0}}), contém: ia (função (a) {return a = a.replace (_, aa), função (b) {return (b. textContent || b.innerText || e (b)). indexOf (a)> - 1}}), lang: ia (função (a) {return U.test (a || "") || ga.error ("sem suporte lang:" + a), um = a.replace (_, aa) .toLowerCase (), função (b) {var c; do if (c = p? b.lang: b.getAttribute ("xml :lang ") || b.getAttribute (" lang ")) return c = c.toLowerCase (), c === a || 0 === c.indexOf (a +" - "); while ((b = b .parentNode) && 1 === b.nodeType); retorno! 1}}), target: function (b) {var = a.location && a.location.hash; return c && c.slice (1) === b.id }, root: function (a) {retorno a === o}, foco: function (a) {retorno a === n.activeElement && (! n.hasFocus || n.hasFocus ()) && !! (a .type || a.href || ~ a.tabIndex)}, ativado: oa (! 1), desativado: oa (! 0), verificado: function (a) {var b = a.nodeName.toLowerCase (); return "input" === b && !! a.checked || "option" === b && !! a.selected}, selecionado: function (a) {return a.parentNode && a.parentNode.selectedIndex, a.selected == =! 0}, empty: function (a) {para (a = a.firstChild; a; a = a.nextSibling) if (a.nodeType <6) retorna! 1; return! 0}, parent: function (a ) {return! d.pseudos.empty (a)}, cabeçalho:function (a) {retornar X.test (a.nodeName)}, entrada: function (a) {retorno W.test (a.nodeName)}, botão: function (a) {var b = a.nodeName.toLowerCase ( ); return "input" === b && "button" === a.type || "button" === b}, texto: function (a) {var b; retorno "input" === a.nodeName .toLowerCase () && "text" === a.type && (null == (b = a.getAttribute ("type")) || "texto" === b.toLowerCase ())}, primeiro: pa ( function () {return [0]}), last: pa (função (a, b) {retorno [b-1]}), eq: pa (função (a, b, c) {retorno [c <0? c + b: c]}), par: pa (função (a, b) {para (var c = 0; c <b; c + = 2) a.push (c); retorno a}), ímpar: pa (função (a, b) {para (var c = 1; c <b; c + = 2) a.push (c); retornar a}), lt: pa (função (a, b, c) {para ( var d = c <0 c + b: c; - d> = 0;) a.push (d); retorne a}), gt: pa (função (a, b, c) {para (var d = c <0c + b: c; ++ d <b;) a.push (d); retorne a}}}}, d.pseudos.nth = d.pseudos.eq;para (b em {radio:! 0, checkbox:! 0, arquivo:! 0, senha:! 0, imagem:! 0}) d.pseudos [b] = ma (b); para (b em {submit: ! 0, reset:! 0}) d.pseudos [b] = na (b); função ra () {} ra.prototype = d.filters = d.pseudos, d.setFilters = novo ra, g = ga. tokenize = função (a, b) {var c, e, f, g, h, i, j, k = z [a + ""]; se (k) retornar b? 0: k.slice (0); h = a, i = [], j = d.preFilter; enquanto (h) {c &&! (e = Q.exec (h)) || (e && (h = h.slice (e [0] .comprimento) | h), i.push (f = [])), c =! 1, (e = R.exec (h)) && (c = e.shift (), f.push ({valor: c, tipo : e [0] .replace (P, "")}), h = h.slice (c.length)); para (g em d.filter)! (e = V [g] .exec (h)) || j [g] &&! (e = j [g] (e)) || (c = e.shift (), f.push ({valor: c, tipo: g, correspondências: e}), h = h.slice (c.length)); if (! c) break} retornar b? h.length: h? ga.error (a): z (a, i) .slice (0)}; a) {para (var b = 0, c = a.length, d = ""; b <c; b ++) d + = a [b] .value; retorno d} função ta (a, b, c) {var d = b.dir, e = b.next, f = e || d, g = c &&"parentNode" === f, h = x ++; retorno b.first? function (b, c, e) {while (b = b [d]) se (1 === b.nodeType || g) retornar um (b, c, e); retorno! 1}: função (b, c, i) {var j, k, l, m = [w, h]; se (i) {enquanto (b = b [d] ) if ((1 === b.nodeType || g) && a (b, c, i)) retorna! 0} else while (b = b [d]) if (1 === b.nodeType || g ) if (l = b [u] || (b [u] = {}), k = l [b.uniqueID] || (l [b.uniqueID] = {}), e && e === b.nodeName .toLowerCase ()) b = b [d] || b; sen {if ((j = k [f]) ​​&& j [0] === w && j [1] === h) return m [2] = j [2]; se (k [f] = m, m [2] = a (b, c, i)) retornar! 0} retornar! 1}} função ua (a) {retornar a.length> 1? Function (b, c, d) {var e = a.length; while (e -) se (! a [e] (b, c, d)) retorna! 1; retorna! 0}: a [0]} função va (a, b, c) {para (var d = 0, e = b.length; d <e; d ++) ga (a, b [d], c); retorno c} função wa (a, b , c, d, e) {para (var f, g = [], h = 0, i = comprimento, j = nulo! = b; h <i; h ++) (f = a [h]) && (c &&! c (f, d, e) || (g.push (f), j && b.push (h))); retorno g} função xa (a, b, c, d, e,f) {retornar d &&! d [u] && (d = xa (d)), e &&! e [u] && (e = xa (e, f)), ia (função (f, g, h, i) {var j, k, l, m = [], n = [], o = g.length, p = f || va (b || "*", h.nodeType? [h]: h, [] ), q =! a ||! f && b? p: wa (p, m, a, h, i), r = c? e || (f? a: o || d)? []: g: q ; if (c & c (q, r, h, i), d) {j = wa (r, n), d (j, [], h, i), k = j.length; enquanto (k--) (l = j [k]) && (r [n [k]] =! (q [n [k]] = l))} se (f) {se (e || a) {se (e) { j = [], k = r.length, enquanto (k -) (l = r [k]) &&j.push (q [k] = l); e (nulo, r = [], j, i) } k = r.length; enquanto (k -) (l = r [k]) && (j = e? I (f, l): m [k])> - 1 && (f [j] =! ( g [j] = l))}} mais r = wa (r === g? r.splice (o, r.length): r), e? e (null, g, r, i): G. aplicar (g, r)})} função ya (a) {para (var b, c, e, f = comprimento, g = d.relativo [a [0]. tipo], h = g || d .relativo [""], i = g? 1: 0, k = ta (função (a) {retorno a === b}, h,! 0), l = ta (função (a) {retorno I ( b, a)> - 1}, h,! 0), m = [função (a, c, d) {var e =! g && (d || c! == j) || ((b = c) .nodeType? k (a, c, d): l (a, c, d)); retorno b = nulo, e}]; i <f; i ++) if (c = d.relativo [a [i] .type ]) m = [ta (ua (m), c)]; senão {if (c = d.filter [a [i] .tipo] .apply (nulo, a [i] .matos), c [u] ) {for (e = ++ i; e <f; e ++) if (d.relative [a [e] .type]) break; retorno xa (i> 1 & ua (m), i> 1 && sa (a.slice ( 0, i-1) .concat ({valor: "" === a [i-2] .tipo? "*": ""})) Substitua (P, "$ 1"), c, i <e & ya (a.slice (i, e)), e <f && ya (a = a.slice (e)), e <f && sa (a)}} m.push (c)} retorno ua (m)} função za (a , b) {var = comprimento_com> 0, e = a.length> 0, f = função (f, g, h, i, k) {var l, o, q, r = 0, s = " 0 ", t = f && [], u = [], v = j, x = f || e && d.find.TAG (" * ", k), y = w + = nulo == v? 1: Math.random () || .1, z = x.length; para (k && (j = g === n || g || k); s! == z && nulo! = (L = x [s]); s ++) {if (e & l) {o = 0, g || l.ownerDocument === n || (m (l), h =! p); enquanto (q = a [o ++]) se (q (l, g || n,h)) {i.push (l); quebra} k && (w = y)} c && ((l =! q && l) && r -, f && t.push (l)}} se (r + = s, c && s! == r) {o = 0; enquanto (q = b [o ++]) q (t, u, g, h); se (f) {se (r> 0) enquanto (s -) t [s] || u [s] || (u [s] = E.call (i)); u = wa (u)} G.apply (i, u), k &&! f & u.length> 0 && r + b.length> 1 && ga. uniqueSort (i)} return k && (w = y, j = v), t}; retorno c? ia (f): f} return h = ga.compile = funç˜ao (a, b) {var c, d = [ ], e = [], f = A [a + ""]; se (! f) {b || (b = g (a)), c = b.length; enquanto (c -) f = ya ( b [c]), f [u] d.push (f): e.push (f); f = A (a, za (e, d)), f.selector = a} retorno f}, i = ga.select = função (a, b, c, e) {var f, i, j, k, l, m = "função" == tipo de a && a, n =! e && g (a = m.selector || a ) if (c = c || [], 1 === n.length) {if (i = n [0] = n [0] .segmento (0), i.length> 2 && "ID" == = (j = i [0]). type && 9 === b.nodeType && p && d.relative [i [1] .type]) {se (b = (d.find.ID (j.matches [0] .replace (_, aa), b) || []) [0],! B) retorno c; m && (b = b.parentNode), a = a.slice (i. shift (). value.length)} f = V.needsContext.test (a)? 0: i.length; while (f -) {se (j = i [f], d.relativo [k = j. type]) break; if ((l = d.find [k]) && (e = l (j.matos [0] .replace (_, aa), $. teste (i [0] .tipo) && qa ( b.parentNode) || b))) {se (i.splice (f, 1), a = e.length && sa (i) ,! a) retorna G.apply (c, e), c; quebra}}} return (m || h (a, n)) (e, b,! p, c,! b || $ .test (a) && qa (b.parentNode) || b), c}, c.sortStable = u.split (""). sort (B) .join ("") === u, c.detectDuplicates = !! l, m (), c.sortDetached = ja (função (a) {retorno 1 & a.compareDocumentPosition (n.createElement ("fieldset"))}), ja (função (a) {return a.innerHTML = "<a href='#'> </a>", "#" === a.firstChild. getAttribute ("href")}) || ka ("tipo | href | altura | largura", função (a, b,c) {se (! c) retornar a.getAttribute (b, "type" === b.toLowerCase ()? 1: 2)}), c.attributos && ja (function (a) {return a.innerHTML = "< input /> ", a.firstChild.setAttribute (" valor "," ")," "=== a.firstChild.getAttribute (" valor ")}) || ka (" valor ", função (a, b, c) {if (! c && "input" === a.nodeName.toLowerCase ()) return a.defaultValue}), ja (function (a) {retorno nulo == a.getAttribute ("desativado")}) | | ka (J, função (a, b, c) {var d; if (! c) retorna a [b] ===! 0? b.toLowerCase () :( d = a.getAttributeNode (b)) && d .especificado? d.value: null}), ga} (a); r.find = x, r.expr = x.selectores, r.expr [":"] = r.expr.pseudos, r.uniqueSort = r.unique = x.uniqueSort, r.text = x.getText, r.isXMLDoc = x.isXML, r.contains = x.contains, r.escapeSelector = x.escape; var y = função (a, b, c ) {var d = [], e = void 0! == c; while ((a = a [b]) && 9!== a.nodeType) if (1 === a.nodeType) {if (e & r (a) .é (c)) pausa; d.push (a)} retorno d}, z = função (a, b) {para (var c = []; a; a = a.nextSibling) 1 === a.nodeType && a! == b && c.push (a); retorno c}, A = r.expr.match.needsContext; função B (a, b) {return a.nodeName && a.nodeName.toLowerCase () === b.toLowerCase ()} var C = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> |) $ / i, D = / ^. [^: # \ [\ .,] * $ /; função E (a, b, c) {retorno r.isFunção (b)? r.grep (a, função (a, d) {retorno !! b.call (a, d, a )! == c}): b.nodeType? r.grep (a, função (a) {return a === b! == c}): "string"! = tipo de b? r.grep (a, função (a) {retorno i.call (b, a)> - 1! == c}): D.test (b) r.filter (b, a, c) :( b = r.filter (b , a), r.grep (a, função (a) {retorno i.call (b, a)> - 1! == c && 1 === a.nodeType}))} r.filter = função (a, b , c) {var d = b [0]; retorno c && (a = ": not (" + a + ")"), 1 === b.length && 1 === d.nodeType? r.find.matchesSelector (d, a)? [d]: []: r.find.matches (a, r.grep (b, funo (a) {retorno 1 === a.nodeType}))}, r.fn.extend ({find: function (a) {var b, c, d = este.length, e = isso; if ("string"! = typeof a) retorna isso. pushStack (r (a) .filter (função () {para (b = 0; b <d; b ++) se (r.contains (e [b], this)) retornar! 0})); para (c = this.pushStack ([]), b = 0; b <d; b ++) r.find (a, e [b], c); retorno d> 1? r.uniqueSort (c): c}, filter: function (a) {return this.pushStack (E (isso, a || [] ,! 1))}, não: function (a) {return this.pushStack (E (isso, um || [], 0) )}, é: function (a) {return !! E (isto, "string" == tipoof a && A.test (a)? r (a): a || [] ,! 1) .comprimento}}); var F, G = / ^ (?: \ s * (<[\ w \ W] +>) [^>] * | # ([\ w -] +)) $ /, H = r.fn.init = function (a, b, c) {var e, f; if (! a) retorna isto; if (c = c || F, "string" == typeof a) {if (e = "<" == = a [0] && ">" === a [a.length-1] && a.length> = 3? [null, a, null]: G.exec (a),! e || e e [1] && b) return! b || b.jquery? (b || c) .find (a): this.constructor (b) .find (a); if (e [1]) {if (b = b instanceof r? b [0]: b, r.merge (isto, r.parseHTML (e [1], b && b.nodeType? B.ownerDocument || b: d,! 0)), C.test (e [1]) && r.isPlainObject (b)) para (e em b) r.isFunction (isto [ e])? this [e] (b [e]): this.attr (e, b [e]); retorne isto} return f = d.getElementById (e [2]), f && (this [0] = f, this.length = 1), this} retorna a.nodeType? (this [0] = a, this.length = 1, isto): r.isFunction (a)? void 0! == c.ready? c .ready (a): a (r): r.makeArray (a, isto)}; H.prototipo = r.fn, F = r (d); var I = / ^ (?: pais | prev (?: Até | Todos)) /, J = {filhos:! 0, conteúdo:! 0, próximo:! 0, prev:! 0}; r.fn.extend ({tem: function (a) {var b = r ( a, this), c = b.length, retornar this.filter (function () {para (var a = 0; a <c; a ++) if (r.contains (isto, b [a])) return! 0 })}, mais próximo: function (a, b) {var c, d = 0, e = this.length, f = [],g = "string"! = tipo de a && r (a); if (! A.test (a)) para (; d <e; d ++) para (c = this [d]; c & c = c = c = c .parentNode) if (c.nodeType <11 && (g? g.index (c)> - 1: 1 === c.nodeType && r.find.matchesSelector (c, a))) {f.push (c); } return this.pushStack (f.length> 1? r.uniqueSort (f): f)}, index: function (a) {retorna uma? "string" == tipoof a? i.call (r (a), this [0]): i.call (isso, a.jquery? a [0]: a): this [0] && this [0] .parentNode? this.first (). prevAll (). tamanho: -1} , adicione: function (a, b) {retornar this.pushStack (r.uniqueSort (r.merge (this.get (), r (a, b))))}, addBack: function (a) {retorne isso. add (null == a? this.prevObject: this.prevObject.filter (a))}}); função K (a, b) {while ((a = a [b]) && 1! == a.nodeType) ; return a} r.each ({parent: function (a) {var b = a.parentNode; retorno b && 11! == b.nodeType? b: null}, pais: function (a) {retorno y (a, " parentNode ")},parentsUntil: function (a, b, c) {return y (a, "parentNode", c)}, next: function (a) {retornar K (a, "nextSibling")}, prev: function (a) {return K (a, "previousSibling")}, nextAll: function (a) {retorno y (a, "nextSibling")}, prevAll: function (a) {retorno y (a, "previousSibling")}, nextUntil: function ( a, b, c) {return y (a, "nextSibling", c)}, prevUntil: function (a, b, c) {return y (a, "previousSibling", c)}, irmãos: function (a) {return z ((a.parentNode || {}). firstChild, a)}, children: function (a) {retorno z (a.firstChild)}, conteúdo: function (a) {retorno B (a, "iframe ")? a.contentDocument: (B (a," template ") && (a = a.content || a), r.merge ([], a.childNodes))}}, function (a, b) { r.fn [a] = função (c, d) {var e = r.map (isto, b, c); retorno "Até"! == a.slice (-5) && (d = c), d && "string" == typeof d && (e = r.filtro (d, e)), this.length> 1 && (J [a] || r.uniqueSort (e), I.test (a) && e.reverse ()), this.pushStack (e)}}; var L = / [^ \ x20 \ t \ r \ n \ f] + / g; função M (a) {var b = {}; retorno r.each (a.match (L) || [], função (a, c) {b [c] =! 0}), b} r.Callbacks = função (a) {a = "string" == tipoof a? M (a): r.extend ({}, a var, c, d, e, f = [], g = [], h = -1, i = função () {para (e = e || a.once, d = b =! 0; g.length; h = -1) {c = g.shift (); enquanto (++ h <f.length) f [h] .apply (c [0], c [1]) ===! 1 && a .stopOnFalse && (h = f.length, c =! 1)} a.memória || (c =! 1), b =! 1, e && (f = c? []: "")}, j = {adicionar : function () {return f && (c &&! b && (h = f.length-1, g.push (c)), função d (b) {r.each (b, função (b, c) {r.isFunção (c)? a.unique && j.has (c) || ​​f.push (c): c && c.length && "string"! == r.type (c) && d (c)})} (argumentos), c &&! b && i ()), this}, remova:function () {return r.each (argumentos, função (a, b) {var c; enquanto ((c = r.inArray (b, f, c))> - 1) f.splice (c, 1), c <= h && h -}), isto}, tem: function (a) {return a? r.inArray (a, f)> - 1: f.length> 0}, vazio: function () {return f && ( f = []), this}, desabilitado: function () {return e = g = [], f = c = "", this}, desabilitado: function () {return! f}, lock: function () { return e = g = [], c || b || (f = c = ""), this}, locked: function () {retorno !! e}, fireWith: function (a, c) {retorno e | | (c = c || [], c = [a, c.slice? c.slice (): c], g.push (c), b || i ()), isto}, fogo: função ( ) {return j.fireWith (this, arguments), this}, disparado: function () {return !! d}}; return j}; function N (a) {retorno a} função O (a) {throw a} função P (a, b, c, d) {var e; try {a && r.isFunction (e = a.promise)? e.call (a) .do (b) .fail (c): a && r.isFunction (e = a.then)? e.call (a, b, c): b.apply (void 0, [a] .slice (d)}} catch (a) {c.apply (void 0, [a]) }} r.extend ({Deferred: function (b) {var = = [["notify", "progress", r.Callbacks ("memória"), r.Callbacks ("memória"), 2], ["resolver", " done ", r.Callbacks (" once memory "), r.Callbacks (" once memory "), 0," resolvido "], [" reject "," fail ", r.Callbacks (" once memory "), r .Callbacks ("once memory"), 1, "rejected"]], d = "pendente", e = {estado: function () {return d}, sempre: function () {return f.done (argumentos). fail (argumentos), this}, "catch": function (a) {return e.then (null, a)}, pipe: function () {var a = argumentos; return r.Deferred (função (b) {r .cada (c, função (c, d) {var e = r.isFunção (a [d [4]]) && a [d [4]]; f [d [1]] (função () {var a = e & e.apply (isto, argumentos); a && r.isFunction (a.promise)? a.promise () .progride (b.notify) .done (b.resolve).fail (b.reject): b [d [0] + "com"] (isto, e? [a]: argumentos)})}), a = null}). promise ()}, then: function (b , d, e) {var f = 0; função g (b, c, d, e) {função return () {var h = isto, i = argumentos, j = função () {var a, j; ! (b <f)) {se (a = d.apply (h, i), a === c.promise ()) lança novo TypeError ("Auto-resolução de subida"); j = a && ("objeto") == typeof a || "function" == typeof a) && a.then, r.isFunction (j)? e? j.call (a, g (f, c, N, e), g (f, c, O, e)): (f ++, j.call (a, g (f, c, N, e), g (f, c, O, e), g (f, c, N, c.notificarCom)) ): (d! == N && (h = void 0, i = [a]), (e || c.resolveWith) (h, i))}}, k = e? j: function () {try { j ()} captura (a) {r.Deferred.exceptionHook && r.Deferred.exceptionHook (a, k.stackTrace), b + 1> = f && (d! == O && (h = void 0, i = [a]) , c.rejectWith (h, i))}}; b? k () :( r.Deferred.getStackHook && (k.stackTrace = r.Deferred.getStackHook ()), a.setTimeout (k))}} retorno r .Diferido (função (a) {c [0] [3] .add (g (0, a, r.isFunção (e)? E: N, a.notificarCom)), c [1] [3] .add ( g (0, a, r.isFunção (b) b: N)), c [2] [3] .add (g (0, a, r.isFunção (d) d: O))}). promise ()}, promessa: function (a) {return nulo! = a? r.extend (a, e): e}}, f = {}; retorno r.each (c, funç˜ao (a, b) { var g = b [2], h = b [5] e [b [1]] = g.add, h && g.add (function () {d = h}, c [3-a] [2]. desabilitar, c [0] [2] .lock), g.add (b [3] .fire), f [b [0]] = função () {retorno f [b [0] + "Com"] ( isto === f? void 0: this, arguments), isto}, f [b [0] + "Com"] = g.fireWith}), e.promise (f), b && b.call (f, f) , f}, quando: function (a) {var b = argumentos.length, c = b, d = Matriz (c), e = f.call (argumentos), g = r.Deferred (), h = function ( a) {função de retorno (c) {d [a] = isto, e [a] = argumentos.length> 1? f.call (argumentos): c, - b || g.resolveWith (d, e)} } if (b <= 1 && (P (a, g.done (h (c)). resolver, g.reject,! b), "pendente" === g.state () || r.isFunction ( e [c] &&e [c]. then))) return g.then (); while (c -) P (e [c], h (c), g.reject); retorno g.promise ()}}); var Q = / ^ (Eval | Internal | Range | Referência | Sintaxe | Tipo | URI) Erro $ /; r.Deferred.exceptionHook = função (b, c) {a.console && a.console.warn && b && Q.test (b.name) && a.console.warn ("exceção jQuery.Deferred:" + b.message, b.stack, c)}, r.readyException = função (b) {a.setTimeout (function () {lance b})}; var R = r.Deferred (); r.fn.ready = function (a) {retorno R.then (a) ["catch"] (função (a) {r.readyException (a);readyException = function (b) {a.setTimeout (function () {lance b})}; var R = r.Deferred (); r.fn.ready = function (a) {retorno R.then (a) [" catch "] (function (a) {r.readyException (a);readyException = function (b) {a.setTimeout (function () {lance b})}; var R = r.Deferred (); r.fn.ready = function (a) {retorno R.then (a) [" catch "] (function (a) {r.readyException (a);
}}, this}, r.extend ({isReady:! 1, readyWait: 1, pronto: function (a) {(a ===! 0? - r.readyWait: r.isReady) || (r. isReady =! 0, a! ==! 0 && - r.readyWait> 0 || R.resolveWith (d, [r]))}}), r.ready.then = R. then; function S () { d.removeEventListener ("DOMContentLoaded", S), a.removeEventListener ("carregar", S), r.ready ()} "completo" === d.readyState || "carregamento"! == d.readyState &&! d .documentElement.doScroll? a.setTimeout (r.ready) :( d.addEventListener ("DOMContentLoaded", S), um.addEventListener ("load", S)); var T = função (a, b, c, d , e, f, g) {var h = 0, i = a.length, j = null == c; if ("objeto" === r.type (c)) {e =! 0; para (h em c) T (a, b, h, c [h], 0, f, g)} else if (void 0! == d && (e =! 0, r.isFunction (d) || (g = ! 0), j && (g? (B.call (a, d), b = nulo) :( j = b, b = função (a, b, c) {retorno j.call (r (a), c )})), b)) para (; h <i; h ++) b (a [h], c, g d: d.call (a [h], h, b (a [h],c))); return e? a: j? b.call (a): i? b (a [0], c): f}, U = funo (a) {retorno 1 === a.nodeType | | 9 === a.nodeType ||! + A.nodeType}; função V () {this.expando = r.expando + V.uid ++} V.uid = 1, V.prototype = {cache: function (a ) {var b = a [this.expando]; retorno b || (b = {}, U (a) && (a.nodeType? a [this.expando] = b: Object.defineProperty (a, this.expando , {valor: b, configurável:! 0}))), b}, conjunto: function (a, b, c) {var d, e = this.cache (a); if ("string" == tipo de b ) e [r.camelCase (b)] = c; senão para (d em b) e [r.camelCase (d)] = b [d]; retorne e}, obtenha: function (a, b) {return void 0 === b? This.cache (a): a [this.expando] && a [this.expando] [r.camelCase (b)]}, acesso: function (a, b, c) {retorno void 0 = == b || b && "string" == typeof b && void 0 === c? this.get (a, b) :( this.set (a, b, c), void 0! == c? c: b )}, remove: function (a, b) {var c, d = a [this.expando]; if (void 0! == d) {if (void 0! == b) {Array.isArray (b) b = b.map (r.camelCase):(b = r.camelCase (b), b = b em d? [b]: b.match (L) || []), c = b.length, enquanto (c -) exclui d [b [c ]]} (void 0 === b || r.isEmptyObject (d)) && (a.nodeType? a [this.expando] = void 0: apaga um [this.expando])}}, hasData: function ( a) {var b = a [this.expando]; return void 0! == b &&! r.isEmptyObject (b)}}; var W = novo V, X = novo V, Y = / ^ (?: \ { [\ w \ W] * \} | \ [[w \ W] * \]) $ /, Z = / [AZ] / g; função $ (a) {retorno "verdadeiro" === a || "false"! == a && ("null" === a? null: a === + a + ""? + a: Y.test (a)? JSON.parse (a): a)} função _ ( a, b, c) {var d; if (void 0 === c && 1 === a.nodeType) if (d = "dados -" + b.replace (Z, "- $ &"). toLowerCase () , c = a.getAttribute (d), "string" == typeof c) {try {c = $ (c)} captura (e) {} X.set (a, b, c)} mais c = void 0 ; return c} r.extend ({hasData: function (a) {retornar X.hasData (a) || W.hasData (a)}, dados: function (a, b, c) {retorno X.acesso (a , b, c)}, removeData:função (a, b) {X.remove (a, b)}, _ dados: função (a, b, c) {retorno W.acesso (a, b, c)}, _ removeData: function (a, b) { W.remove (a, b)}}), r.fn.extend ({dados: function (a, b) {var c, d, e, f = este [0], g = f && f.atributos; if ( void 0 === a) {if (this.length && (e = X.get (f), 1 === f.nodeType &&! W.get (f, "hasDataAttrs"))) {c = g.length; while (c -) g [c] && (d = g [c] .nome, 0 === d.indexOf ("dados -") && (d = r.camelCase (d.slice (5)), _ (f, d, e [d]))); W.set (f, "hasDataAttrs",! 0)} return e} retorna "objeto" == typeof a? this.each (function () {X. set (this, a)}): T (isso, function (b) {var c; if (f && void 0 === b) {if (c = X.get (f, a), void 0! == c ) return c; if (c = _ (f, a), void 0! == c) return c} else this.each (function () {X.set (isso, a, b)})}, null, b, arguments.length> 1, null,! 0)}, removeData: function (a) {retornar this.each (function () {X.remove (isso, a)})}}), r.extend ({ fila: função (a,b, c) {var d; se (a) retornar b = (b || "fx") + "fila", d = W.get (a, b), c && (! d || Array.isArray (c ) d = W.access (a, b, r.makeArray (c)): d.push (c)), d || []}, dequeue: function (a, b) {b = b || " fx "; var c = r.queue (a, b), d = c.length, e = c.shift (), f = r._queueHooks (a, b), g = função () {r.dequeue ( a, b)}; "inprogress" === e && (e = c.shift (), d -), e && ("fx" === b && c.unshift ("inprogress"), delete f.stop, e .call (a, g, f)),! d && f && f.empty.fire ()}, _ queueHooks: function (a, b) {var c = b + "queueHooks"; retorno W.get (a, c) || ​​W .access (a, c, {vazio: r.Callbacks ("once memory"). adicionar (function () {W.remove (a, [b + "fila", c])})})}}, r .fn.extend ({fila: function (a, b) {var = 2; return "string"! = tipo de a && (b = a, a = "fx", c -), argumentos.length <c? r.queue (this [0], a): void 0 === b? this: this.each (function () {var c = r.queue (isso, a, b); r._queueHooks (isso, a), "fx" === a && "inprogress"! == c [0] && r.dequeue ( isso, a)})}, dequeue: function (a) {retornar this.each (function () {r.dequeue (this, a)}), clearQueue: function (a) {retornar this.queue (a | | "fx", []}}, promessa: function (a, b) {var c, d = 1, e = r.Deferred (), f = isto, g = este.length, h = function () { --d || e.resolveWith (f, [f])}; "string"! = tipo de um && (b = a, a = void 0), a = a || "fx"; while (g--) c = W.get (f [g], a + "queueHooks"), c && c.empty && (d ++, c.empty.add (h)); retorno h (), e.promise (b)}}); var aa = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -]? \ d + |) /. source, ba = novo RegExp ("^ (?: ([ + -]) = |) ("+ aa +") ([az%] *) $ "," i "), ca = [" Superior "," Direita "," Inferior "," Esquerda "], da = função (a, b) {retorno a = b || a, "nenhum" === a.style.display || "" === a.style.display && r.contains (a.ownerDocument, a) && "none" === r.css (a, "display")}, ea = função (a, b, c , d) {var e, f, g = {}; para (f in b) g [f] = a.style [f], a.style [f] = b [f]; e = c.apply ( a, d || []); para (f em b) a.style [f] = g [f]; return e}; função fa (a, b, c, d) {var e, f = 1, g = 20, h = d? função () {retorno d.cur ()}: function () {retorno r.css (a, b, "")}, i = h (), j = c & c [3] || (r.cssNumber [b]? "": "px"), k = (r.cssNumber [b] || "px"! == j && + i) && ba.exec (r.css (a, b )); se (k & k [3]! == j) {j = j || k [3], c = c || [], k = + i || 1; do f = f || ".5 ", k / = f, r.style (a, b, k + j); enquanto (f! == (f = h () / i) && 1! == f && - g)} retorno c && (k = + k || + i || 0, e = c [1]? k + (c [1] +1) * c [2]: + c [2], d && (d.unidade = j, d.start = k, d.end = e)), e} var ga = {}; função ha (a) {var b, c = a.proprietárioDocumento, d = a.nodeNome, e = ga [d]; return e? e :(b = c.body.appendChild (c.createElement (d)), e = r.css (b, "exibição"), b.parentNode.removeChild (b), "nenhum" === e && (e = " bloco "), ga [d] = e, e)} função ia (a, b) {para (var c, d, e = [], f = 0, g = a.length; f <g; f ++) d = a [f], d.style && (c = d.style.display, b? ("nenhum" === c && (e [f] = W.get (d, "display") || null, e [f] || (d.style.display = "")), "" === d.style.display && da (d) && (e [f] = ha (d))): "nenhum"! == c && (e [f] = "nenhum", W.set (d, "display", c))), para (f = 0; f <g; f ++) null! = e [f] && (a [f ] .style.display = e [f]); return a} r.fn.extend ({show: function () {return ia (isso,! 0)}, hide: function () {return ia (isso)} , toggle: function (a) {return "booleano" == typeof a? a? this.show (): this.hide (): this.each (function () {da (isso)? r (this) .show (): r (this) .hide ()})}}); var ja = / ^ (?:checkbox | radio) $ / i, ka = / <([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] +) / i, la = / ^ $ | \ / (? java | ecma) script / i, ma = {opção: [1, "<select multiple = 'multiple'>", "</ select>"], thead: [1, "<table>", "</ table > "], col: [2," <tabela> <colgroup> "," </ colgroup> </ table> "], tr: [2," <tabela> <tbody> "," </ tbody> < / table> "], td: [3," <tabela> <tbody> <tr> "," </ tr> </ tbody> </ table> "], _ padrão: [0," "," "] }; ma.optgroup = ma.option, ma.tbody = ma.tfoot = ma.colgroup = ma.caption = ma.thead, ma.th = ma.td; funca na (a, b) {var c; c = "undefined"! = typeof a.getElementsByTagName? a.getElementsByTagName (b || "*"): "indefinido"! = tipo de a.querySelectorAll? a.querySelectorAll (b || "*"): [], void 0 === b || b && B (a, b)? r.merge ([a], c): c} funcao oa (a, b) {para (var c = 0, d = a.length; c <d; c ++) W.set (a [c], "globalEval",! b || W.get (b [c], "globalEval"))} var pa = / <| & #? \ w +; /; função qa (a, b, c, d, e) {para (var f, g, h, i, j, k, l = b.createDocumentFragment () , m = [], n = 0, o = a.length; n <o; n ++) if (f = a [n], f || 0 === f) if ("objeto" === r. tipo (f)) r.merge (m, f.nodeType? [f]: f); senão se (pa.test (f)) {g = g || l.appendChild (b.createElement ("div") ), h = (ka.exec (f) || ["", ""]) [1] .toLowerCase (), i = ma [h] || ma._default, g.innerHTML = i [1] + r.htmlPrefilter (f) + i [2], k = i [0], enquanto (k -) g = g.lastChild; r.merge (m, g.childNodes), g = l.firstChild, g. textContent = ""} mais m.push (b.createTextNode (f)); l.textContent = "", n = 0; while (f = m [n ++]) if (d && r.inArray (f, d)> - 1) e & e.push (f); caso contrário, se (j = r.contém (f.ownerDocument, f), g = na (l.appendChild (f), "script"), j && oa (g), c) {k = 0; enquanto (f = g [k ++]) la.test ( f.type || "") && c.push (f)} retornar l}! function () {var a = d.createDocumentFragment (), b = a.appendChild (d.createElement ("div")), c = d.createElement ("entrada"); c.setAttribute ("tipo", "rádio"), c.setAttribute ("verificado", "verificado"), c.setAttribute ("nome", "t"), b. appendChild (c), o.checkClone = b.cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, b.innerHTML = "<textarea> x </ textarea>", o.noCloneChecked = !! b. cloneNode (! 0) .lastChild.defaultValue} (); var ra = d.documentElement, sa = / ^ chave /, ta = / ^ (?: mouse | ponteiro | contextmenu | arrastar | soltar) | clique em /, ua = /^([^.]*)(?:\.(.+)|)/;function va () {return! 0} função wa () {return! 1} função xa () {try {return d.activeElement} catch (a) {}} função ya (a, b, c, d, e, f) {var g, h; if ("objeto" == typeof b) {"string"! = tipo de c && (d = d || c, c = void 0), para (h em b) ya (a, h, c, d, b [h], f); retorne a} if (null == d && null == e? ( e = c, d = c = void 0): null == e && ("string" == typeof c? (e = d, d = void 0) :( e = d, d = c, c = void 0) ), e ===! 1) e = wa; sen se (! e) retornar a; return 1 === f && (g = e, e = função (a) {retorno r (). off (a), g.apply (this, arguments)}, e.guid = g.guid || (g.guid = r.guid ++)), a.each (function () {r.event.add (isto, b, e, d, c)})} r.event = {global: {}, adicione: function (a, b, c, d, e) {var f, g, h, i, j, k, l, m, n , o, p, q = W.get (a); se (q) {c.handler && (f = c, c = f.handler, e = f.selector), e && r.find.matchesSelector (ra, e) , c.guid || (c.guid = r.guid ++), (i = q.eventos) || (i = q.eventos = {}), (g = q.handle) || (g = q. handle = function (b) {retorno "undefined"! = tipo de r && r.event.triggered! == b.type? r.event.dispatch.apply (a, argumentos): void 0}), b = (b || ""). correspondência (L) || [""], j = b.length; while (j -) h = ua.exec (b [j]) || [], n = p = h [1], o = (h [2] || ""). dividir ("."). sort (), n && ( l = r.event.special [n] || {}, n = (e? l.delegateType: l.bindType) || n, l = r.event.special [n] || {}, k = r .extend ({tipo: n, origType: p, dados: d, manipulador: c, guid: c.guid, seletor: e, needsContext: e && r.expr.match.needsContext.test (e), namespace: o.join (".")}, f), (m = i [n]) || (m = i [n] = [], m.delegateCount = 0, l.setup && l.setup.call (a, d, o , g)! ==! 1 || a.addEventListener && a.addEventListener (n, g)), l.add && (l.add.call (a, k), k.handler.guid || (k.handler.guid = c.guid)), e? m.splice (m.delegateCount ++, 0, k): m.push (k), r.event.global [n] =! 0)}}, remove: function (a, b, c, d, e) {var f, g, h, i, j, k, l, m, n, o, p, q = w .hasData (a) && wget (a); se (q && (i = q.eventos)) {b = (b || "") .match (L) || [""], j = b.length; while (j -) se (h = ua.exec (b [j]) || [], n = p = h [1 ], o = (h [2] || ""). split ("."). sort (), n) {l = r.event.special [n] || {}, n = (d? l .delegateType: l.bindType) || n, m = i [n] || [], h = h [2] && new RegExp ("(^ | \\.)" + o.join ("\\. ( ?:. * \\. |) ") +" (\\. | $) "), g = f = m.length; enquanto (f -) k = m [f],! e && p! == k .origType || c && c.guid! == k.guid || h &&! h.test (k.namespace) || d && d! == k.selector && ("**"! == d ||! k.selector) || (m.splice (f, 1), k.selector && m.delegateCount -, l.remove &&l.remove.call (a, k)); g &&! m.length && (l.teardown && l.teardown.call (a, o, q.handle)! ==! 1 || r.removeEvent (a, n, q.handle), delete i [n])} mais para (n in i) r.event.remove (a, n + b [j], c, d,! 0); r.isEmptyObject (i) && W.remove (a, "manipular eventos")}}, dispatch: function (a) {var b = r.event.fix (a), c, d, e, f, g, h, i = new Matriz (arguments.length), j = (W.get (isto, "eventos") || {}) [b. type] || [], k = r.event.special [b.type] || {}; para (i [0] = b, c = 1; c <argumentos.length; c ++) i [c] = arguments [c]; if (b.delegateTarget = isto,! k.preDispatch || k.preDispatch.call (isto, b)! ==! 1) {h = r.event.handlers.call (isto, b, j), c = 0; while ((f = h [c ++]) &&! b.isPropagationStopped ()) {b.currentTarget = f.elem, d = 0; enquanto ((g = f.handlers [d ++]) &&! b.isImmediatePropagationStopped ()) b.rnamespace &&! b.rnamespace.test (g.namespace) || (b.handleObj = g, b.data = g.data, e = ((r.event.special [g .origType] || {}). handle || g.handler) .apply (f.elem, i), void 0! == e && (b.result = e) ===! 1 && (b.preventDefault () , b.stopPropagation ()))} return k.postDispatch && k.postDispatch.call (this, b), b.result}}, manipuladores: function (a, b) {var c, d, e, f, g, h = [], i = b.delegateCount, j = a.target; if (i && j.nodeType &&! ("click" === a.type && a.button> = 1)) para (; j! == this; j = j.parentNode || this) if (1 === j.nodeType && ("clique" ! == a.type || j.disabled! ==! 0)) {para (f = [], g = {}, c = 0; c <i; c ++) d = b [c], e = d.selector + "", void 0 === g [e] && (g [e] = d.needsContext? r (e, isto) .index (j)> - 1: r.find (e, isto, null , [j]). length), g [e] && f.push (d); f.length && h.push ({elem: j, manipuladores: f})} return j = isto, i <b.length && h.push ( {elem: j, manipuladores: b.slice (i)}), h}, addProp: function (a, b) {Object.defineProperty (r.Evento.prototipo, a, {enumerável:! 0, configurável:! 0 get: r.isFunction (b)? function () {if (this.originalEvent) retornar b (this.originalEvent)}: function () {if (this.originalEvent) retornar this.originalEvent [a]}, conjunto: function (b) {Object.defineProperty (isso, a, {enumerável:! 0, configurável:! 0, gravável:! 0, valor: b})}})}, correção:function (a) {retornar a [r.expando]? a: novo r.Evento (a)}, especial: {load: {noBubble:! 0}, foco: {trigger: function () {if (this! = = xa () && this.focus) return this.focus (),! 1}, delegateType: "focusin"}, borrão: {trigger: function () {if (this === xa () && this.blur) devolve este .blur () ,! 1}, delegateType: "focusout"}, clique: {trigger: function () {if ("checkbox" === this.type && this.click && B (this, "input")) retornar this.click () ,! 1}, _ default: function (a) {retorno B (a.target, "a")}}, beforeunload: {postDispatch: função (a) {void 0! == a.result && a.originalEvent && (a .originalEvent.returnValue = a.result)}}}}, r.removeEvent = function (a, b, c) {a.removeEventListener && a.removeEventListener (b, c)}, r.Event = function (a, b) { return this instanceof.Event? (a && a.type? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue ===! 1? va: wa, this.target = a.target && 3 === a.target.nodeType? a.target.parentNode: a .target, this.currentTarget = a.currentTarget, this.relatedTarget = a.relatedTarget): this.type = a, b && r.extend (this, b), this.timeStamp = a && a.timeStamp || r.now (), void (this [r.expando] =! 0)): novo r.Event (a, b)}, r.Event.prototype = {construtor: r.Event, isDefaultPrevented: wa, isPropagationStopped: wa, isImmediatePropagationStopped: wa, isSimulated:! 1, preventDefault: function () {var a = this.originalEvent; this.isDefaultPrevented = va, a &&! this.isSimulated && a.preventDefault ()}, stopPropagation: function () {var a = este.originalEvento; isto. isPropagationStopped = va, a &&! this.isSimulated && a.stopPropagation ()}, stopImmediatePropagation: function () {var a = este.originalEvento; isto.isImmediatePropagationStopped = va, a &&! this.isSimulated && a.stopImmediatePropagation (), this.stopPropagation ()}}, r.each ({altKey:! 0, bolhas:! 0, cancelável:! 0, changedTouches:! 0, ctrlKey :! 0, detalhe:! 0, eventPhase:! 0, metaKey:! 0, pageX:! 0, páginaY:! 0, shiftKey:! 0, view:! 0, "char":! 0, charCode:! 0, chave :! 0, keyCode:! 0, botão:! 0, botões:! 0, clientX:! 0, clientY:! 0, offsetX:! 0, deslocamentoY:! 0, pointerId:! 0, ponteiroTipo:! 0, screenX :! 0, screenY:! 0, targetTouches:! 0, toElement:! 0, toca:! 0, que: function (a) {var b = a.button; retorno null == a.which && sa.test (a. type)? null! = a.charCode? a.charCode: a.keyCode:! a.which && void 0! == b && ta.test (a.type)? 1 & b? 1: 2 & b? 3: 4 & b? 2: 0: a .which}}, r.event.addProp), r.each ({mouseenter: "mouseover", mouseeleave: "mouseout", pointerenter: "pointerover", ponteirolinha: "ponteiroout"),função (a, b) {r.event.special [a] = {delegateType: b, bindType: b, identificador: função (a) {var c, d = isso, e = a.relatedTarget, f = a.handleObj ; return e && (e === d || r.contains (d, e)) || (a.type = f.origType, c = f.handler.apply (isto, argumentos), a.type = b) , c}}}), r.fn.extend ({on: function (a, b, c, d) {retornar ya (isso, a, b, c, d)}, um: função (a, b, c, d) {retorno ya (isso, a, b, c, d, 1)}, off: função (a, b, c) {var d, e; se (a && a.preventDefault && a.handleObj) retornar d = a .handleObj, r (a.delegateTarget) .off (d.namespace? d.origType + "." + d.namespace: d.origType, d.selector, d.handler), isto; if ("object" == typeof a) {para (e em a) this.off (e, b, a [e]); retorne isto} return b! ==! 1 && "function"! = typeof b || (c = b, b = void 0), c ===! 1 && (c = wa), this.each (função () {r.event.remove (isto, a, c, b)})}}); var za = / <(? ! area | br | col | embed | h | img | entrada | link | meta | param) (([az] [^ \ / \ 0>\ x \ \ t \ r \ n \ f] *) [^>] *) \ /> / gi, Aa = / <script | <estilo | <link / i, Ba = / marcado \ s * (?: [ ^ =] | = \ s * .checked.) / i, Ca = / ^ verdadeiro \ / (. *) /, Da = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g; function Ea (a, b) {retorno B (a, "tabela") && B (11! == b.nodeType? b: b. firstChild, "tr")? r ("> tbody", a) [0] || a: a} função Fa (a) {return a.type = (null! == a.getAttribute ("type")) + "/" + a.type, a} função Ga (a) {var b = Ca.exec (a.type); return b? a.type = b [1]: a.removeAttribute ("tipo"), a} função Ha (a, b) {var c, d, e, f, g, h, i, j; se (1 === b.nodeType) {if (W.hasData (a) && (f = W.access (a), g = wset (b, f), j = f.eventos)) {excluir g.handle, g.eventos = {}; para (e em j) para (c = 0, d = j [e] .length; c <d; c ++) r.event.add (b, e, j [e] [c])} X.hasData (a) && (h = X.acesso (a) , i = r.extend ({}, h), X.set (b, i))}} função Ia (a, b) {var = b.nodeName.toLowerCase (); "entrada"=== c && ja.test (a.type)? b.checked = a.checked: "entrada"! == c && "textarea"! == c || (b.defaultValue = a.defaultValue)} função Ja (a , b, c, d) {b = g.apply ([], b); var e, f, h, i, j, k, l = 0, m = comprimento a, n = m-1, q = b [0], s = r.isFunção (q); se (s || m> 1 && "string" == tipoof q &&! o.checkClone && Ba.test (q)) retorne a.each (function (e) { var f = a.eq (e); s && (b [0] = q.call (isto, e, f.html ())), Ja (f, b, c, d)}); if (m && ( e = qa (b, a [0] proprietárioDocumento,! 1, a, d), f = e.firstChild, 1 === e.childNodes.length && (e = f), f || d)) {para (h = r.map (na (e, "script"), Fa), i = h.length; l <m; l ++) j = e, l! == n && (j = r.clone (j ,!) 0,! 0), i && r.merge (h, na (j, "script"))), c.call (a [l], j, l); se (i) para (k = h [h.length -1] .ownerDocument, r.map (h, Ga), l = 0; l <i; l ++) j = h [l], la.test (j.type || "") &&! W.access ( j, "globalEval") && r.contains (k, j) && (j.src? r._evalUrl && r._evalUrl (j.src): p (j.textContent.replace (Da, ""), k))} retornar a} função Ka (a , b, c) {para (var d, e = b? r.filter (b, a): a, f = 0; nulo! = (d = e [f]); f ++) c || 1! = = d.nodeType || r.cleanData (na (d)), d.parentNode && (c && r.contains (d.ownerDocument, d) && oa (na (d, "script")), d.parentNode.removeChild (d) ); return a} r.extend ({htmlPrefilter: function (a) {return a.replace (za, "<$ 1> </ $ 2>")}, clone: ​​function (a, b, c) {var d, e, f, g, h = a.cloneNode (! 0), i = r.contains (a.ownerDocument, a); if (! (o.noCloneChecked || 1! == a.nodeType && 11! == a. nodeType || r.isXMLDoc (a))) para (g = na (h), f = na (a), d = 0, e = f.length; d <e; d ++) Ia (f [d], g [d]); se (b) se (c) para (f = f || na (a), g = g || na (h), d = 0, e = comprimento f, d <e; d ++) Ha (f [d], g [d]), senão Ha (a, h); retorno g = na (h, "script"), g.length> 0 && oa (g,! i &&na (a, "script")), h}, cleanData: function (a) {para (var b, c, d, e = r.event.special, f = 0; void 0! == (c = a [f]); f ++) if (U (c)) {se (b = c [W.expando]) {se (b.eventos) para (d em b.eventos) e [d] r.evento. remove (c, d): r.removeEvent (c, d, b.handle); c [W.expando] = void 0} c [X.expando] && (c [X.expando] = void 0)}} }), r.fn.extend ({detach: function (a) {retornar Ka (isso, a,! 0)}, remover: function (a) {retornar Ka (this, a)}, text: function (a ) {return T (isto, função (a) {return void 0 === a? r.text (this): this.empty (). each (função () {1! == this.nodeType && 11! == this .nodeType && 9! == this.nodeType || (this.textContent = a)})}, null, a, arguments.length)}, anexar: function () {return Ja (isso, argumentos, função (a) {se (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var b = Ea (isso, a); b.appendChild (a)}})}, prepended : function () {return Ja (isto, argumentos, função (a) {if (1 === this.nodeType || 11 === isto.nodeType || 9 === this.nodeType) {var b = Ea (isto, a); b.insertBefore (a, b.firstChild)}})}, antes de: function () {return Ja (isto, argumentos, function (a) {this.parentNode && this.parentNode.insertBefore (a, this)})}, depois: function () {return Ja (isso, argumentos, função (a) {this.parentNode && this.parentNode.insertBefore (a, this .nextSibling)})}, vazio: function () {para (var a, b = 0; nulo! = (a = este [b]); b ++) 1 === a.nodeType && (r.cleanData (na ( a,! 1)), a.textContent = ""); retorne isto}, clone: ​​function (a, b) {return a = null! = a && a, b = null == b? a: b, this.map (function () {return r.clone (isso, a, b)})}, html: function (a) {retorno T (isso, função (a) {var b = this [0] || {}, c = 0, d = this.length; if (vazio 0 === a && 1 === b.nodeType) return b.innerHTML; if ("string" == tipo de um &&! Aa.test (a) &&! Ma [( ka.exec (a) || ["", ""]) [1] .toLowerCase ()]) {a = r.htmlPrefilter (a); tente {para (; c <d; c ++) b = este [c] || {}, 1 === b.nodeType && (r.cleanData (na (b,! 1)), b. innerHTML = a); b = 0} catch (e) {}} b && this.empty (). append (a)}, null, a, argumentos.length)}, replaceWith: function () {var a = []; return Ja (isto, argumentos, função (b) {var c = this.parentNode; r.inArray (isto, a) <0 && (r.cleanData (na (this)), c && c.replaceChild (b, this)}} , a)}}), r.each ({appendTo: "append", prependTo: "prepend", insertBefore: "antes", insertAfter: "after", replaceAll: "replaceWith"}, function (a, b) { r.fn [a] = função (a) {para (var c, d = [], e = r (a), f = e.length-1, g = 0; g <= f; g ++) c = g === f? this: this.clone (! 0), r (e [g]) [b] (c), h.apply (d, c.get ()); retorne this.pushStack (d) }}); var La = / ^ margin /, Ma = novo RegExp ("^ (" + aa + ") (! px) [az%] + $", "i"), Na = função (b) { var c = b.ownerDocument.defaultView;return c && c.opener || (c = a), c.getComputedStyle (b)};! função () {função b () {if (i) {i.style.cssText = "tamanho da caixa: border-box; posição: relativo; display: bloco; margem: auto; borda: 1px; preenchimento: 1px; topo: 1%; largura: 50% ", i.innerHTML =" ", ra.appendChild (h); var b = a. getComputedStyle (i); c = "1%"! == b.top, g = "2px" === b.marginLeft, e = "4px" === b.width, i.style.marginRight = "50 % ", f =" 4px "=== b.marginRight, ra.removeChild (h), i = nulo}} var c, e, f, g, h = d.createElement (" div "), i = d .createElement ("div"); i.style && (i.style.backgroundClip = "caixa de conteúdo", i.cloneNode (! 0) .style.backgroundClip = "", o.clearCloneStyle = "caixa de conteúdo" == = i.style.backgroundClip, h.style.cssText = "borda: 0; largura: 8px; altura: 0; topo: 0; esquerda: -9999px; preenchimento: 0; margem superior: 1px; posição: absoluto", h.appendChild (i), r.extend (o, {pixelPosition: function () {retorno b (), c}, boxSizingReliable: function () {retorno b (), e}, pixelMarginRight: function () {retorno b () , f}, reliableMarginLeft: function () {retorno b (), g}})}} (); função Oa (a, b, c) {var d, e, f, g, h = a.style; c = c || Na (a), c && (g = c.getPropertyValue (b) || c [b], ""! == g || r.contains (a.ownerDocument, a) || (g = r.style (a, b), o.pixelMarginRight () && Ma.test (g) && La.test (b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h. minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f)), void 0! == g? g + "": g } function Pa (a, b) {return {get: function () {return a ()? void delete this.get: (this.get = b) .apply (isto, argumentos)}}} var Qa = / ^ (nenhum | tabela (?! - c [ea]). +) /, Ra = / ^ - /, Sa = {posição: "absoluto", visibilidade: "oculto", exibição: "bloco"}, Ta = {letterSpacing: "0",fontWeight: "400"}, Ua = ["Webkit", "Moz", "ms"], Va = d.createElement ("div"). style; função Wa (a) {if (a em Va) retorna um ; var b = a [0] .toUpperCase () + a.slice (1), c = Ua.length; enquanto (c -) se (a = Ua [c] + b, a em Va) retorna um} função Xa (a) {var b = r.cssProps [a]; return b || (b = r.cssProps [a] = Wa (a) || a), b} função Ya (a, b, c) {var d = ba.exec (b); retorno d? Math.max (0, d [2] - (c || 0)) + (d [3] || "px"): b} funo Za ( a, b, c, d, e) {var f, g = 0; para (f = c === (d? "fronteira": "conteúdo")? 4: "largura" === b? 1: 0; f <4; f + = 2) "margem" === c && (g + = r.css (a, c + ca [f], 0, e)), d? ("Conteúdo" === c && (g- = r.css (a, "preenchimento" + ca [f], 0, e)), "margem"! == c && (g- = r.css (a, "fronteira" + ca [f ] + "Largura",! 0, e))): (g + = r.css (a, "preenchimento" + ca [f], 0, e), "preenchimento"! == c && (g + = r.css (a, "border" + ca [f] + "largura",! 0, e))); retorno g} função $ a (a, b, c) {var d, e = Na (a), f = Oa (a, b, e), g = "caixa de borda" === r.css (a, "boxSizing",! 1, e); retorno Ma.test (f)? F: (d = g && (o.boxSizingReliable () || f === a.style [b]), "auto" === f && (f = a ["deslocamento" + b [0] .toUpperCase () + b.slice (1 )]), f = parseFloat (f) || 0, f + Za (a, b, c || (g? "fronteira": "conteúdo"), d, e) + "px")} r.extend ({cssHooks: {opacidade: {get: function (a, b) {if (b) {var c = Oa (a, "opacidade"); retorno "" === c? "1": c}}} }, cssNumber: {animationIterationCount:! 0, columnCount:! 0, fillOpacity:! 0, flexGrow:! 0, flexRelação:! 0, fontWeight:! 0, lineHeight:! 0, opacidade:! 0, ordem:! 0, órfãos:! 0, widows:! 0, zIndex:! 0, zoom:! 0}, cssProps: {"float": "cssFloat"}, estilo: function (a, b, c, d) {se (a && 3! == a.nodeType && 8! == a.nodeType && a.style) {var e, f, g, h = r.camelCase (b), i = Ra.test (b), j = a.style; retorno i || (b = Xa (h)), g = r.cssHooks [b] || r.cssHooks [h], void 0 === c? g && "get" em g && void 0! == (e = g.get (a,! 1, d))? e : j [b]: (f = tipo c, "string" === f && (e = ba.exec (c)) && e [1] && (c = fa (a, b, e), f = "número "), null! = c && c === c && (" número "=== f && (c + = e && [3] || (r.cssNumber [h]?" ":" px ")), o.clearCloneStyle || ""! == c || 0! == b.indexOf ("background") || (j [b] = "herdar"), g && "set" em g && void 0 === (c = g.set ( a, c, d)) || (i? j.setProperty (b, c): j [b] = c)), void 0)}}, css: funï¿½o (a, b, c, d) {var e, f, g, h = r.camelCase (b), i = Ra.test (b); retorno i || (b = Xa (h)), g = r.cssHooks [b] || r.cssHooks [h], g && "get" em g && (e = g.get (a,! 0, c)), void 0 === e && (e = Oa (a, b, d)), "normal" === e && b em Ta && (e = Ta [b]), "" === c || c? (f = parseFloat (e), c ===! 0 || isFinite (f)? f || 0: e): e}}), r.each (["altura", "largura"], função (a, b) {r.cssHooks [b] = {get: function (a, c, d) {se (c) retornar! Qa.test (r.css (a, "display")) || a.getClientRects (). length && a.getBoundingClientRect () Largura? $ a (a, b, d): ea (a, Sa, função () {return $ a (a, b, d)})}, conjunto: função (a, c, d) {var , f = d && Na (a), g = d & a Za (a, b, d, "caixa de borda" === r.css (a, "boxSizing",! 1, f), f); retorno g && (e = ba.exec (c)) && "px"! == (e [3] || "px") && (a.style [b] = c, c = r.css (a, b)), Ya ( a, c, g)}}}), r.cssHooks.marginLeft = Pa (o.reliableMarginLeft, function (a, b) {se (b) return (parseFloat (Oa (a, "marginLeft")) || um .getBoundingClientRect (). left-ea (a, {marginLeft: 0}, function () {retornar a.getBoundingClientRect (). left})) + "px"}), r.each ({margin: "", padding: "", border: "Width"}, função (a, b) {r.cssHooks [a + b] = {expandir: function (c) {para (var d = 0, e = {}, f = "string" == typeof c? c.split (""): [c]; d <4; d ++ ) e [a + ca [d] + b] = f [d] || f [d-2] || f [0]; retorne e}}, La.test (a) || (r.cssHooks [ a + b] .set = Ya)}), r.fn.extend ({css: função (a, b) {retornar T (isso, função (a, b, c) {var d, e, f = { }, g = 0; if (Array.isArray (b)) {para (d = Na (a), e = comprimento_b; g <e; g ++) f [b [g]] = r.css (a , b [g] ,! 1, d); return f} return void 0! == c? r.style (a, b, c): argumentos r.css (a, b)}, a, b. length> 1)}}), r.fn.delay = function (b, c) {return b = r.fx? r.fx.speeds [b] || b: b, c = c || "fx" , this.queue (c, função (c, d) {var e = a.setTimeout (c, b); d.stop = função () {a.clearTimeout (e)}})}, function () {var a = d.createElement ("input"), b = d.createElement ("select"), c = b.appendChild (d.createElement ("option")); a.type = "caixa de seleção", o.checkOn = ""! == a.value, o.optSelected = c.selected, a = d.createElement ("entrada" ), a.value = "t", a.type = "radio", o.radioValue = "t" === a.value} (); var _a, ab = r.expr.attrHandle; r.fn. extend ({attr: function (a, b) {retornar T (isto, r.attr, a, b, argumentos.length> 1)}, removeAttr: function (a) {retornar this.each (function () {r .removeAttr (this, a)})}}), r.extend ({attr: function (a, b, c) {var d, e, f = a.nodeType; se (3! == f && 8! == f && 2! == f) return "undefined" == tipoof a.getAttribute? r.prop (a, b, c): (1 === f && r.isXMLDoc (a) || (e = r.attrHooks [b. toLowerCase ()] || (r.expr.match.bool.test (b)? _a: void 0)), void 0! == c? null === c? void r.removeAttr (a, b): e && "set" em e && void 0! == (d = e.set (a, c, b)) d: (a.setAttribute (b, c + ""), c): e& "get" em e && null! == (d = e.get (a, b)) d d: (d = r.find.attr (a, b), nulo == d vo void 0: d))} , attrHooks: {tipo: {set: function (a, b) {if (! o.radioValue && "radio" === b && B (a, "input")) {var = a.value; retorno a.setAttribute ( "type", b), c && (a.value = c), b}}}}, removeAttr: function (a, b) {var c, d = 0, e = b && b.match (L); if (e & 1 === a.nodeType) while (c = e [d ++]) a.removeAttribute (c)}}), _a = {set: function (a, b, c) {retorno b ===! 1? r. removeAttr (a, c): a.setAttribute (c, c), c}}, r.each (r.expr.match.bool.source.match (/ \ w + / g), função (a, b) { var c = ab [b] || r.find.attr; ab [b] = funç˜ao (a, b, d) {var e, f, g = b.toLowerCase (); retorno d || (f = ab [g], ab [g] = e, e = null! = c (a, b, d)? g: null, ab [g] = f), e}}); var bb = / ^ (?: input | select | textarea | button) $ / i, cb = / ^ (?: a | área) $ / i; r.fn.extend ({prop: function (a, b) {retorno T (isto, r. prop, a, b, arguments.length> 1)}, removeProp:function (a) {return this.each (function () {delete this [r.propFix [a] || a]})}}), r.extend ({prop: função (a, b, c) {var d, e, f = a.nodeType; if (3! == f && 8! == f && 2! == f) retorno 1 === f && r.isXMLDoc (a) || (b = r.propFix [b] || b, e = r.propHooks [b]), void 0! == c? e && "set" em e && void 0! == (d = e.set (a, c, b))? d: a [b] = c: e && "get" em e && null! == (d = e.get (a, b))? d: a [b]}, propHooks: {tabIndex: {get: função (a) {var b = r .find.attr (a, "tabindex"); retorna b? parseInt (b, 10): bb.test (nnode.nome) || cb.test (nnodeNome.a) && a.href? 0: -1}} }, propFix: {"for": "htmlFor", "class": "className"}}}, o.optSelected || (r.propHooks.selected = {get: function (a) {var b = a.parentNode ; return b && b.parentNode && b.parentNode.selectedIndex, null}, conjunto: function (a) {var b = a.parentNode; b && (b.selectedIndex,b.parentNode && b.parentNode.selectedIndex)}}), r.each (["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", " frameBorder "," contentEditable "], function () {r.propFix [this.toLowerCase ()] = esta}); function db (a) {var b = a.match (L) || []; retorno b. função join ("")} eb (a) {return a.getAttribute && a.getAttribute ("classe") || ""} r.fn.extend ({addClass: function (a) {var b, c, d, e , f, g, h, i = 0; if (r.isFunction (a)) retornar this.each (function (b) {r (this) .addClass (a.call (isso, b, eb (isso)) )}); if ("string" == typeof a && a) {b = a.match (L) || []; while (c = isto [i ++]) if (e = eb (c), d = 1 = == c.nodeType && "" + db (e) + "") {g = 0; enquanto (f = b [g ++]) d.indexOf ("" + f + "") <0 && (d + = f + ""); h = db (d), e! == h && c.setAttribute ("classe", h)}} retornar isto}, removeClass: function (a) {var b, c, d, e, f, g, h, i = 0; se (r.isFunction (a)) retorne this.each (function (b) {r (this) .removeClass (a.call (isto, b, eb) ))}); if (! arguments.length) retorna this.attr ("class", ""); if ("string" == typeof a && a) {b = a.match (L) || []; (c = isto [i ++]) se (e = eb (c), d = 1 === c.nodeType && "" + db (e) + "") {g = 0; enquanto (f = b [g ++] ) while (d.indexOf ("" + f + "")> - 1) d = d.replace ("" + f + "", ""); h = db (d), e! == h && c.setAttribute ( "class", h)}} retornar isto}, toggleClass: function (a, b) {var c = tipo de um; return "booleano" == typeof b && "string" === c? b? this.addClass (a ): this.removeClass (a): r.isFunction (a)? this.each (função (c) {r (isto).toggleClass (a.call (isso, c, eb (isso), b), b)}): this.each (function () {var b, d, e, f; if ("string" === c) {d = 0, e = r (isto), f = a.match (L) || []; enquanto (b = f [d ++]) e.hasClass (b) e.removeClass (b): e. addClass (b)} else void 0! == a && "booleano"! == c || (b = eb (isto), b && W.set (isto, "__ className __", b), this.setAttribute && this.setAttribute ("classe ", b || a ===! 1?" ": W.get (isso," __ nome_da_classe __ ") ||" "))})}, hasClass: function (a) {var b, c, d = 0 b = "" + a + ""; while (c = isto [d ++]) if (1 === c.nodeType && ("" + db (eb (c)) + "") .indexOf (b)> - 1) return! 0; return! 1}}); var fb = / \ r / g; r.fn.extend ({val: function (a) {var b, c, d, e = este [0]; {if (arguments.length) retorna d = r.isFunction (a), this.each (função (c) {var e; 1 === this.nodeType && (e = d? a.call (isto, c, r (this) .val ()): a, null == e? e = "":"número" == tipoof e? e + = "": Array.isArray (e) && (e = r.map (e, função (a) {retorno nulo == a? "": a + ""})), b = r.valHooks [this.type] || r.valHooks [this.nodeName.toLowerCase ()], b && "set" em b && void 0! == b.set (isto, e, "valor") || ( this.value = e))}); if (e) retorna b = r.valHooks [e.type] || r.valHooks [e.nodeName.toLowerCase ()], b && "get" em b && void 0! == (c = b.get (e, "valor"))? c: (c = e.value, "string" == tipo de c? c.replace (fb, ""): null == c? "": c)}}}), r.extend ({valHooks: {opção: {get: function (a) {var b = r.find.attr (a, "valor"); retorno nulo! = b? b: db (r.text (a))}}, selecione: {get: function (a) {var b, c, d, e = a.options, f = a.selectedIndex, g = "select-one" === a.type, h = g? null: [], i = g? f + 1: e.length; para (d = f <0? i: g? f: 0; d <i; d ++) se (c = e [d], (c.selecionado || d === f) &&! c.disabled && (! c.parentNode.disabled ||! B (c.parentNode, "optgroup"))) {if (b = r (c) .val (), g) return b; h.push (b)} return h}, set: function (a, b) {var c, d, e = a.options, f = r.makeArray (b), g = e.length ; while (g -) d = e [g], (d.selecionado = r.inArray (r.valHooks.option.get (d), f)> - 1) && (c =! 0); retorno c || (a.selectedIndex = -1), f}}}}), r.each (["rádio", "caixa de seleção"], function () {r.valHooks [this] = {set: function (a, b) {if (Array.isArray (b)) return a.checked = r.inArray (r (a) .val (), b)> - 1}}, o.checkOn || (r.valHooks [isto] .get = function (a) {return null === a.getAttribute ("valor")? "em": a.value})}); var gb = / ^ (?: focusinfocus | focusoutblur) $ /; r .extend (r.event, {trigger: função (b, c, e, f) {varg, h, i, j, k, m, n, o = [e || d], p = l.call (b, "type")? b.type: b, q = l.call (b, "espaço de nomes")? b.namespace.split ("."): [];if (h = i = e = e || d, 3! == e.nodeType && 8! == e.nodeType &&! gb.test (p + r.event.triggered) && (p.indexOf (".")> -1 && (q = p.split ("."), P = q.shift (), q.sort ()), k = p.indexOf (":") <0 && "em" + p, b = b [r.expando]? b: novo r.Event (p, "objeto" == typeof b && b), b.isTrigger = f? 2: 3, b.namespace = q.join ("."), b.rnamespace = b.namespace? new RegExp ("(^ | \\.)" + q.join ("\\. (?:. * \\. |)") + "(\\. | $)"): null, b.result = void 0, b.target || (b.target = e), c = null == c? [b]: r.makeArray (c, [b]), n = r.event. special [p] || {}, f ||! n.trigger || n.trigger.apply (e, c)! ==! 1)) {if (! f &&! n.noBubble &&! r.isWindow (e )) {for (j = n.delegateType || p, gb.test (j + p) || (h = h.parentNode); h; h = h.parentNode) o.push (h), i = h ; i === (e.ownerDocument || d) && o.push (i.defaultView || i.parentWindow || a)} g = 0;while ((h = o [g ++]) &&! b.isPropagationStopped ()) b.type = g> 1? j: n.bindType || p, m = (wget (h, "eventos") || {}) [b.type] && W.get (h, "manipular"), m && m.apply (h, c), m = k && h [k], m && m.apply && U (h) && (b.result = m.apply (h, c), b.result ===! 1 && b.preventDefault ()); return b.type = p, f || b.isDefaultPrevented () || n._default && n._default.apply (o.pop () , c)! ==! 1 ||! U (e) || k && r.isFunction (e [p]) &&! r.isWindow (e) && (i = e [k], i && (e [k] = null), r.event.triggered = p, e [p] (), r.event.triggered = void 0, i && (e [k] = i)), b.result}}, simula: function (a, b, c) {var d = r.extend (novo r.Evento, c, {tipo: a, éSimulado:! 0}); r.event.trigger (d, nulo, b)}}), r.fn .extend ({trigger: function (a, b) {retornar this.each (function () {r.event.trigger (a, b, this)})}, triggerHandler: função (a, b) {var c = isso [0]; if (c) retorna r.event.gatilho (a, b, c,! 0)}}), r.each ("borrar foco foco em focusout redimensionar rolar clique dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave alterar selecionar enviar keydown keypress keyup contextmenu" .split (""), function (a, b) {r.fn [b] = função (a, c) {retorno arguments.length> 0? this.on (b, nulo, a, c): this.trigger (b)}}) , r.fn.extend ({hover: function (a, b) {retornar this.mouseenter (a) .mouseleave (b || a)}}), o.focusin = "onfocusin" em a, o.focusin | | r.each ({focus: "focusin", blur: "focusout"}, função (a, b) {var = função (a) {r.event.simulate (b, a.target, r.event. fixe (a)); r.event.special [b] = {configuração: function () {var d = this.ownerDocument || isto, e = W.access (d, b); e || d.addEventListener (a, c, 0), W.access (d, b, (e || 0) +1)}, desmontagem: function () {var d = this.ownerDocument || this, e = W.access ( d, b) -1; e? W.acesso (d, b, e) :( d.removeEventListener (a, c,! 0), W.remove (d, b))}}}); var hb = / \ [\] $ /, ib = / \ r? \ n / g, jb = / ^ (?: enviar | botão | imagem | redefinir | arquivo) $ / i, kb = / ^ (?: entrada | selecione | área de texto | keygen) / i; função lb (a, b, c, d) {var e; if (Array.isArray (b)) r.each (b, função (b, e) {c || hb.test (a)? d (a, e): lb (a + "[" + ("objeto" == typeof e && null! = e? b: "") + "]", e, c, d);
senão se (c || "objeto"! == r.tipo (b)) d (a, b); senão para (e em b) lb (a + "[" + e + "]", b [ e], c, d)} r.param = função (a, b) {var c, d = [], e = função (a, b) {var c = r.isFunção (b)? b (): b d [d.length] = encodeURIComponent (a) + "=" + encodeURIComponent (nulo == c? "": c)}; if (Array.isArray (a) || a.jquery &&! r.isPlainObject ( a)) r.each (a, function () {e (this.name, this.value)}); else para (c em a) lb (c, a [c], b, e); retorno d. join ("&")}, r.fn.extend ({serializar: function () {retornar r.param (this.serializeArray ())}, serializeArray: function () {retornar este.map (function () {var a = r.prop (isso, "elementos"); retorne um? r.makeArray (a): este}). filter (function () {var a = this.type; retorne this.name &&! r (this). é (": disabled") && kb.test (this.nodeName) &&! jb.test (a) && (this.checked ||! ja.test (a))}). map (função (a,b) {var c = r (isto) .val (); retorno nulo == c? nulo: Array.isArray (c)? r.map (c, funç˜ao (a) {return {nome: b.name, valor : a.replace (ib, "\ r \ n")}}): {nome: b.name, valor: c.replace (ib, "\ r \ n")}}). get ()}}) , r.fn.extend ({wrapAll: function (a) {var b; retorne isto [0] && (r.isFunction (a) && (a = a.call (this [0])), b = r ( a, this [0] .ownerDocument) .eq (0) .clone (! 0), this [0] .parentNode && b.insertBefore (this [0]), b.map (função () {var a = isto; (a.firstElementChild) a = a.firstElementChild; retorne um}). append (this)), este}, wrapInner: function (a) {return r.is[0] .ownerDocument) .eq (0) .clone (! 0), this [0] .parentNode && b.insertBefore (this [0]), b.map (função () {var a = this; while (a .firstElementChild) a = a.firstElementChild; retorne um}). append (this)), este}, wrapInner: function (a) {return r.is[0] .ownerDocument) .eq (0) .clone (! 0), this [0] .parentNode && b.insertBefore (this [0]), b.map (função () {var a = this; while (a .firstElementChild) a = a.firstElementChild; retorne um}). append (this)), este}, wrapInner: function (a) {return r.isFunção (a)? This.each (função (b) {r (isto) .wrapInner (a.call (this, b))}): this.each (function () {var b = r (isto), c = b.contents (); c.length? c.wrapAll (a): b.append (a)})}, wrap: function (a) {var b = r.isFunction (a); devolva this.each ( function (c) {r (this) .wrapTudo (b? a.call (isto, c): a)})}, desembrulhe: function (a) {return this.parent (a) .not ("corpo") .each (function () {r (this) .replaceWith (this.childNodes)}), isto}}), r.expr.pseudos.hidden = function (a) {retorno! r.expr.pseudos.visible (a )}, r.expr.pseudos.visible = function (a) {retorno !! (a.offsetWidth || a.offsetHeight || a.getClientRects (). length)}, o.createHTMLDocument = function () {var a = d.implementation.createHTMLDocument (""). body; return a.innerHTML = "<formulário> </ form> <formulário> </ form>", 2 === a.childNodes.length} (), r. parseHTML = function (a, b, c) {if ("string"! = typeof a) return []; "booleano"== typeof b && (c = b, b =! 1); var e, f, g; return b || (o.createHTMLDocument? (b = d.implementation.createHTMLDocument (""), e = b.createElement ( "base"), e.href = d.location.href, b.head.appendChild (e)): b = d), f = c .exec (a), g =! c && [], f? [b .createElement (f [1])] :( f = qa ([a], b, g), g && g.length && r (g) .remove (), r.merge ([], f.childNodes))}, r .offset = {setOffset: função (a, b, c) {var d, e, f, g, h, i, j, k = r.css (a, "posição"), l = r (a), m = {}; "estático" === k && (a.style.position = "relativo"), h = l.offset (), f = r.css (a, "topo"), i = r.css (a, "esquerda"), j = ("absoluta" === k || "fixa" === k) && (f + i) .indexOf ("auto")> - 1, j? (d = l.position (), g = d.top, e = d.left): (g = parseFloat (f) || 0, e = parseFloat (i) || 0), r.isFunção (b) && (b = b.call (a, c, r.extend ({}, h))), null! = b.top && (m.top = b.top-h.top + g), nulo! = b.left && (m.left = b.left-h.left + e), "usando" em b? b.using.call (a, m): l.css (m) }}, r.fn.extend ({deslocamento: função (a) {if (arguments.length) return void 0 === a? this: this.each (function (b) {r.offset.setOffset (isto, a, b)}); var b, c, d, e, f = este [0]; if (f) retorna f.getClientRects (). length? (d = f.getBoundingClientRect (), b = f.ownerDocumento , c = b.documentElement, e = b.defaultView, {superior: d.top + e.pageYOffset-c.clientTop, esquerda: d.left + e.pageXOffset-c.clientLeft}): {topo: 0, esquerda : 0}}, posição: function () {if (isto [0]) {var a, b, c = isto [0], d = {topo: 0, esquerdo: 0}; retorno "fixo" === r.css (c, "position")? b = c.getBoundingClientRect (): (a = this.offsetParent (), b = this.offset (), B (a [0], "html") || ( d = a.offset ()), d = {superior: d.top + r.css (a [0], "borderTopWidth",! 0), esquerda: d.left + r.css (a [0], "borderLeftWidth",! 0)}), {top: b.top-d.top-r.css (c, "marginTop",! 0), esquerda: b.left-d.left-r.css (c, "marginLeft",! 0)}}}, offsetParente: function () {retornar this.map (function () {var a = this .offsetParent; while (a && "static" === r.css (a, "position")) a = a.offsetParent; retorna a || ra})}}) r.each ({scrollLeft: "pageXOffset" , scrollTop: "pageYOffset"}, função (a, b) {var = "pageYOffset" === b; r.fn [a] = função (d) {return T (isto, função (a, d, e ) {var f; return r.isWindow (a)? f = a: 9 === a.nodeType && (f = a.defaultView), void 0 === e? f? f [b]: a [d] : void (f? f.scrollTo (c? f.pageXOffset: e, c? e: f.pageYOffset): a [d] = e)}, a, d, argumentos.length)}}), r.each (["top", "left"], função (a, b) {r.cssHooks [b] = Pa (posição de o.pixel, função (a, c) {if (c) retorno c = Oa (a, b ), Ma.test (c) r (a) .position () [b] + "px": c})}), r.each ({altura: "altura", largura: "largura"}, função (a, b) {r.each ({padding: "inner" + a, conteúdo: b, "": "outer" + a}, função (c, d) {r.fn [d] = função (e, f) {var g = argumentos .length && (c || "booleano"! = typeof e), h = c || (e ===! 0 || f ===! 0? "margin": "border"); retorno T (isto, função (b, c, e) {var f; retorno r.isWindow (b)? 0 === d.indexOf ("exterior")? b ["interior" + a]: b.document.documentElement ["cliente "+ a]: 9 === b.nodeType? (f = b.documentElement, Math.max (b.body [" rolar "+ a], f [" rolar "+ a], b.body [" deslocamento "+ a], f [" offset "+ a], f [" cliente "+ a])): void 0 === e? r.css (b, c, h): r.style (b, c , e, h)}, b, g? e: void 0, g)}})}), r.fn.extend ({bind: funç˜ao (a, b, c) {return this.on (a, null , b, c)}, unbind: function (a, b) {retornar this.off (a, null, b)}, delegado: function (a, b, c, d) {retornar this.on (b, a , c, d)}, undelegate: function (a, b, c) {retorno 1 === argumentos.length? this.off (a, "**"): this.off (b, a || "**", c)}}), r.holdReady = função (a) {a? r.readyWait ++: r .ready (! 0)}, r.isArray = Array.isArray, r.parseJSON = JSON.parse, r.nodeName = B, "função" == tipoof define && define.amd && define ("jquery", [], function () {return r}); var mb = a.jQuery, nb = a. $; return r.noConflict = função (b) {return a. $ === r && (a. $ = nb), b && a.jQuery == = r && (a.jQuery = mb), r}, b || (a.jQuery = a. $ = r), r});jQuery === r && (a.jQuery = mb), r}, b || (a.jQuery = a. $ = r), r});jQuery === r && (a.jQuery = mb), r}, b || (a.jQuery = a. $ = r), r});
